#+title: C言語練習

学習の流れ

* 最初のプログラムと仕様情報
** 最初のプログラム「Hello, world!」
最初のプログラムの定番であるハローワールドを作成してみましょう。
適当なテキストエディタを使ってhelloworld.cを作成して下さい。中身は以下のとおりです。

※表記について
$はシェルのプロンプトをプロンプトとなります。シェルにcatコマンドを引数helloworld.cを
渡している状況となりますので、#includeからはhelloworld.cの内容となります。

$ cat helloworld.c 
#include <stdio.h>            /* 最初はおまじない */

int main(void)                /* main関数 : おまじない */
{
  printf("Hello, world!\n");
  return 0;                   /* 関数の戻り値 */
}

プログラムを記述したこの様なファイルをソースコードといいます。
作成できたら、コマンドとして実行できるファイルに変換します。

$ gcc helloworld.c 

a.outというファイルができていたら、以下の様に実行します。

$ ./a.out 
Hello, world!

画面に「Hello, world!」は出力されましたでしょうか。
a.out以外のファイル名にしたい場合は、はオプション-oを使用します。

$ gcc helloworld.c -o helloworld
$ ls helloworld
helloworld

** 実行ファイルができるまでの各工程
テキストファイルから実行可能なファイルになるまでは以下のように
複数の工程に分かれています。

1. プリプロセス(ヘッダファイルの処理など)
 　  $ gcc -E helloworld.c

2. コンパイル(.c -> .S)(アセンブラ)
     $ gcc -S helloworld.c

3. アセンブル(.c -> .o)(オブジェクトファイルの生成)
     $ gcc -c helloworld.c

4. リンク
    自分もよくわかっていないので、詳しくは説明できません。

これらの工程は最初のうちはそこまで気にする必要がありません。
白状しますと、リンクの具体的な動作は私もわかりません。

たいていは、gccまたは、gcc -cの使用で十分と思います。
上記のオプションはgccのマニュアルにも記載があり、ヘルプオプション(gcc --help)でも確認できます。

以下のコマンドを実行し、実際に確認してみて下さい。
$ man gcc
$ gcc --help

マニュアルやヘルプにはアセンブラへの変換をコンパイルと呼んでいますが、会話の中では
実行ファイルの作成までをコンパイルといったり、オブジェクトファイルの作成までをコンパイルと
言ったり様々です。なので、厳密な場合でなければ話の文脈で判断して下さい。

*** 発展:オブジェクトファイルのダンプ
オブジェクトの情報はobjdumpコマンドで見ることができます。

$ gcc -c helloworld.c
$ objdump -d helloworld.o 

helloworld.o:     ファイル形式 elf64-x86-64


セクション .text の逆アセンブル:

0000000000000000 <main>:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # f <main+0xf>
   f:	e8 00 00 00 00       	callq  14 <main+0x14>
  14:	b8 00 00 00 00       	mov    $0x0,%eax
  19:	5d                   	pop    %rbp
  1a:	c3                   	retq 
        ^^^^^^^^^^^^^^^^^^^^^^  ^^^^アセンブラ
        マシン語

-dはディスアセンブルオプションとなっています。左の部分はマシン語になっていて、CPUが理解できる命令になっています。
例えば、オフセット4の0x55は「push %rbp」の命令に対応していことになります。

極端な話をすれば、バイナリエディタで、main部分に出力された内容のデータを作成したものと、gccによって出力された
上記のデータが同じであればmainは同じ動きをします。

** 仕様情報
私はこれまでC言語の仕様を気にしてコードを書いたことはありませんが、この機会に情報を仕入れてみました。
私の環境ではGCCを使用しており、バージョンを以下の用に確認すると9.3.0でした。

$ gcc --version
gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

gccのinfoを見ると「2.1 C Language」には、仕様C11にGNUの拡張を加えたものがデフォルトの
動作になっていると記載がありました。

仕様のドラフト版は以下からダウンロードできるのでダウンロードしてみて下さい。

　　仕様のドラフト

　　  ISO C Working Group (http://www.open-std.org/jtc1/sc22/wg14/)
　　    9899: Programming Language C
　　      C11	ISO/IEC 9899:2011	N1570 [2011-04-04]

N1570のリンクからN1570.pdfが取得できます。

** プログラムの終了状態
シェルは最後に実行したプログラムの終了状態を$?に持っており、echoで値を確認することができます。
true, falseコマンドを例に$?の実行結果を確認してみましょう。

まずは、以下のコマンドでtrueとfalseのマニュアルを確認して下さい。

$ man true
$ man false

マニュアルの関連項目には完全なマニュアルはTexinfoマニュアルとして整備されていると記載があります。
以下のコマンドでinfoを確認して下さい。

$ info true
$ info false

実際にtrue, falseコマンドを実行しマニュアルに記載された通りの終了ステータスが得られることを
確認してみて下さい。

$ true; echo $?
0

$ false; echo $?
1

tureやfalseの他にgrepコマンドなども成功と失敗を返しています。
grepのマニュアルを参照し、どの様な終了ステータスを返すのかを確認してみて下さい。

$ man grep

マニュアルには選択行が見つかった場合は0, 見つからなかった場合は1と記載があります。
見つかる場合と見つからない場合の2ケースを実際に試し終了ステータスを確認して下さい。

$ echo abc | grep a; echo $?
abc
0

$ echo abc | grep d; echo $?
1

C言語では、main関数の戻り値(return 0 の 0)がプログラムの終了ステータスとなります。

** 終了ステータスを返すだけの小さなプログラム
helloworld.cでは画面に文字列を出力(printf)するために、おまじない(#include <stdio.h>)を記述しました。
実はこのおまじないは、画面出力(printf)を使用するために記述しています。プログラムの終了ステータスを返すだけの場合は、
画面出力(printf)が不要なので、このおまじないを取り除くことができます。

以下のreturn0.cを作成し実行させてみなさい。

$ cat return0.c 
int main(void)
{
  return 0;
}

$ gcc -Wall return0.c 
$ ./a.out
$ echo $?
0

このプログラムは--helpや--versionのオプションを受け取れませんが、trueコマンドと同じですね。

** プログラム
C言語の様な手続き型言語のプログラムは平たく言えば、逐一やること書いたものの並びと考えてよいです。
注意点として、コンピュータは基本的に忖度しないので、良きに計らうことが無いので、本当に逐一書くことになります。

最近は、スマホなどのように非常に直感的に動作するものがありますが、高度なプログラミングの集積の上に成り立っていると
考えた方がよいでしょう。

プログラムの記述についてエドガー・ダイクストラが提唱した構造化3定理というものがあります。

  - 順次実行
  - 条件分岐
  - 繰り返し

プログラムの要素はつまるところ、上記の3つで記述できるというものです。

*** 発展:XX指向プログラミング
現在の主流のプログラミングは手続き型で作成されていると考えてよいでしょう。
世の中には、「XX指向プログラミング言語」という言葉をよく聞いたり、見たりしますが、意味合いとしては
「XX指向プログラミンをサポートする言語」という理解が良いと思います。

　- 宣言的
    - 関数型 : Haskell
    - 論理型 : Prolog
  - 手続き的
    - アセンブラ
    - C
  - マルチパラダイム
    - Lisp, ...

- Java : 手続き型, オブジェクト指向, 関数型


** 順次実行
C言語は素直に上から下に順次実行されてきますので、処理を上から下に並べて記述すれば順次実行されます。
以下のプログラムを作成し、実際に動作させてみなさい。

$ cat junn.c 
#include <stdio.h>

int main(void)
{
  printf("最初\n");
  printf("次\n");

  return 0;
}

** 問題

   1. 終了ステータス 1 を返すプログラムmyfalseを作成しなさい。

   2. 1 + 2 の計算結果を終了ステータスとして返すプログラムを作成しなさい。

   3. 1から10までの整数の和を終了ステータスとして返すプログラムを作成しなさい。
      (難しく考えず、2. の様に計算機の延長として考えてみよ。)

   4. gccのオプション-Wallについてマニュアルを調べなさい。
      警告を出力してくれるので積極的な利用をおすすめします。

   5. 画面に以下のような文字列を出力するプログラムを作成しなさい。

      $ ./hello2
      hello
      hello

   6. 画面に以下のような文字列を出力するプログラムを作成しなさい。

      $ ./hello3
      hello
       hello
        hello

   7. 画面に以下のような文字列を出力するプログラムを作成しなさい。

      $ ./tree
           *
          * *
         *   *
        *     *
       *********
           *
           *

   8. (質問からの問題)
      シェルスクリプトなどを実行可能にするには、chmodコマンドで実行権を付与するが、
      gccで実行ファイルを実行した場合は最初から実行可能になっている。
   　　なぜですか?

      1. 最初にchmodコマンドが実行ファイルができるまでのどこかの工程で実行されているかもしれない。と予想を立てた。
         プログラムには通常出力しない実行時の詳細情報を出力するオプションを用意している場合がある。
	 gcc に詳細情報を出力する -v または -verbose オプションがあるかをマニュアルから調べてみよ。

	 また、オプションが存在した場合、実際に使用し問題の回答になるかを確かめてみよ。

      2. (関数の後に取り組んだ方がよい)
	 gccはchmodコマンドを呼び出していないようだが、chmodが行っている「ファイルのモードを変更する」という処理と
	 同じ処理を行っているのではないか。と予想を立てた。この「ファイルのモードを変更する」というchmodコマンドの機能は
         何によって実現されているのだろうか。

	 chmodのマニュアルを参照してみよ。特に「関連項目」について見てみよ。

      3. 関連項目の情報から「ファイルのモードを変更する」という機能はchmodシステムコールにより提供されていることが
         わかった。つまり、chmodコマンドはchmodシステムコールを指定したファイルに指定したモードで呼び出すためのコマンドと
	 見ることができる。

	 システムコールをトレースするコマンドstraceがある。straceを使用しchmodシステムコールによって
         実行権が付与されているかを確認してみよ。

* 変数
C言語では変数を使用することができます。
変数とは、値を保持するメモリ領域で変数宣言時に指定した名前(識別子)で値にアクセスすることができます。

** 変数の宣言
変数を使用には予め以下の様に宣言する必要があります。

  保持したい型の情報 名前(識別子) = 値;

値を指定しないで宣言することもできます。

  保持したい型の情報 名前(識別子);

*** 宣言例

  int weekNum = 7;  /* 一週間に日数 */
  double pi = 3.14; /* 円周率(小数点2桁まで) */
  char good = 'A';  /* 評価 */ /* 文字を記述する場合はクォート(')で囲見ます。*/

C言語は型を意識する言語になっています。
型の情報はメモリ領域の確保や、異なる型の演算をユーザーが誤って記述している場合などのチェックに使われています。

** 変数の宣言(配列)
値の中には複数をまとめて管理したい場合があります。
例えば、統計的な処理を行いたい場合、複数の値の中から最大値や最小値を求めることがあります。

以下の様に記述します。配列といいます。

  保持したい型の情報 名前(識別子)[要素数] = { 値1, 値2, ... };

配列の場合も値を指定せずに宣言することができます。

  保持したい型の情報 名前(識別子)[サイズ];

例

  fload weights[3] = { 55.5, 60.0, 70.2 } /* 3つの体重 */
  char hello[] = { 'H', 'e', 'l', 'l', 'o', '\0'} /* 文字列Hello */ /* '\0' は文字列の終端 */
  char hello2[] = "Hello"; /* 上と同じ */ /* 文字列はダブルクォート(")で囲む */

** 初期化と代入
変数の宣言時に値を指定する場合は、初期化といいます。配列の初期化時に要素数を省略した場合はコンパイラが計算してくれます。
保持した情報へのアクセス時は0オリジン(0から数え始める)で[]の中に場所を整数値で指定します。
この整数値のことを、添え字やインデックスといいます。

  weighs[0]  <-- 55.5

指定範囲外へのアクセスはプログラムの異常動作に繋がりますので、注意しましょう。

*** 初期化
変数の宣言と同時に初期値を定める場合を初期化といいます。

  int a = 1; /* 初期化 */

*** 代入
初期化以外のタイミングで変数に加える変更を代入といいます。

  int a;
  a = 2; /* 代入 */

*** プログラム例
幾つかの変数を使用したプログラムvariable.cを実行してみて下さい。

$ cat variable.c 
#include <stdio.h>

int main(void)
{
  /* 符号有り */
  char ch = 'A';
  printf("ch = %c\n", ch);

  short int si = 1024;
  printf("si = %d\n", si);

  int i = 0xffeeddcc;
  printf("i = %d\n", i);

  long int li = 123;
  printf("li = %ld\n", li);

  /* 符号無し */
  unsigned char uch = '@';
  printf("uch = %uc\n", uch);

  unsigned int ui = 0xffeeddcc;
  printf("ui = %ud\n", ui);

  /* 実数 */
  float f = 1.2;
  printf("f = %f\n", f);

  double d = 1.4142e2;
  printf("d = %g\n", d);

  /* 配列 */
  int ia[] = { 1, 2};
  printf("ia[%d] = %d, ia[%d] = %d\n", 0, ia[0], 1, ia[1]);

  /* 変数のアドレス */
  printf("&ch = %p\n", &ch);

  return 0;

}

$ gcc -Wall variable.c 
makoto@insp-7380:~/gitHub/Cprac$ ./a.out 
ch = A
si = 1024
i = -1122868
li = 123
uch = 64c
ui = 4293844428d
f = 1.200000
d = 141.42
ia[0] = 1, ia[1] = 2
&ch = 0x7fff00b836b0

** 紹介していない型
「6.7.2 Type specifiers 2」

** printf
printfは画面にプログラムの情報を出力するのに使うことができます。
学び始めの段階では、実際のプログラムの動作と自分の頭のプログラム動作とが一致しないことが多くあります。
その際、処理の間にprintfを挿入し状況を見ていくというのはプログラムの理解を助けます。

実業務でプログラムを書くようになっても自分の頭とプログラムの動作が一致しないことは日常的に起きます。
つまりは、バグを入れ込んだということです。

慣れてくると、printfではなくデバッガを使ってプログラムの動作を確認する方法を取ることもありますが、
どちらの方法をとるかは状況によります。printfの出力に慣れていて損はないので、ぜひ色々出力させてみて下さい。

*** マニュアル
printfのマニュアルを以下の様に調べるとpritfコマンドについての内容が出てきます。

$ man printf

この様な場合はセクション情報も指定します。

$ man 3 printf

各セクションの情報はmanコマンドのマニュアルで確認できます。
C言語での開発時によく見るのは以下のセクションとなります。

       2   システムコール (カーネルが提供する関数)
       3   ライブラリー呼び出し (プログラムライブラリーに含まれる関数)

インフラ系の人はセクション5のお世話になっているかもしれないですね。(man  hostsなど)

       5   File formats and conventions, e.g. /etc/passwd

** コメント
ソースコード中にはプログラムの動作に影響しないメモとしてコメント記述することができます。

学習時にはプログラムの動作をメモしてみるというのも一つの方法かもしれません。
コメントについては格言もあり、「書かれしことを書くな。書かざれしことを書け」というものがあります。
プログラムが語っている動作をコメントに書く必要は無い。しかし、プログラムが語れないことはコメントとして
書くべきとの格言です。

*** 1行コメント
   // ........

*** 複数行対応
   /* xxxxxx */

   /* 
      aaaaaa
      zzzzzz
    */

*** その他
プリプロセスを利用した例

#if 0

  #if から #endif までのコードが無効になります。

#endif

*** 仕様

「6.4.9 Comments」も合わせて参照してみて下さい。

** 問題
 1. printfの%dを使用するプログラムを作成せよ。
 2. %dを%xに変えて16進数で表示させてみよ。
 3. 変数の型のサイズはsizeof(型)やsizeof(変数名)で取得することができます。
    printfで幾つかの変数のサイズを表示させてみよ。少なくとも以下の方について試しなさい。

    1. char
    2. short
    3. int
    4. long int
    5. char型要素10の配列
    6. int型要素10の配列

 4. printf関数のフラグ文字(0)を使用してみよ。

* 関数
関数(function)には、機能や働きという意味があります。C言語における関数も同じで機能や働きを実現するために使用します。
例えば、printf関数は、指定された書式(f:format)で出力(print)する機能を持っています。

** 関数と抽象化
関数の利点のひとつに指定された使い方を守れば、その機能を利用できるという点があります。
利用にあたっては、関数がどの様に実装されているかは気にする必要がありません。

実生活の中ではこの様なものが多くあります。
例えば、洗濯機ではどのように洗濯するかをボタンで選んでスタートを押せば、洗濯をしてくれます。
利用者は洗濯機が洗濯槽のモーターの電流をどの様に制御しているかは普通知らないと思いますが、洗濯機は使えているはずです。

これは、一種の抽象化といえます。具体的なレベルではモーターの電流などを考えなければいけませんが、
幾つかの回路などを組みあせて、モータ制御部が組み上がり、抽象度が上がっていき、最終的にボタン入力で洗濯ができる。という
段階まできているわけです。

関数を定義していくことは抽象化の層を作っているという感じです。

抽象度高 <----> 抽象度体
洗濯する。
  ボタン入力で洗濯メニューをコントロールする。
    指定メニューに合わせて洗濯機の動作を制御する。
      指定の水位まで水をいれる。
        水の流入口を開く。
      モータを回転制御
        時間経過で逆回転にする。
  :

** 関数定義
戻り値の型 関数名(引数の型 引数の名前)　/* プロトタイプ宣言に使用する部分 */
{
  各種処理;

  return 戻り値;
}

引数が不要な場合はvoidを記述します。
戻り値が不要な場合は戻り値の型を void とします。
戻り値の型がvoidの場合はreturnを省略できます。または、return;とします。

これまで記述したmain関数を見直し見ると上記の形式にちゃんと合っています。

*** プロトタイプ宣言
C言語ではファイルの先頭側で定義した関数1からファイルの後の方で定義した関数2を使用すると、
コンパイル時に警告:暗黙の型宣言がでます。この警告が出る理由は、これは、関数1のコンパイル時に関数2の
型情報が無いために、コンパイラが「型の情報が無いのでわかりません〜」と言っているわけです。

この様な問題を回避するため、関数の型情報をプロトタイプ宣言としてファイルの先頭の方に記述します。
プロトタイプ宣言は関数定義の一部を記述します。

**** 例 : 暗黙の宣言(implicit declaration)
$ cat implicit.c 
int main(void)
{
  return f();
}

int f(void)
{
  return 1;
}

$ gcc -Wall f.c 
f.c: In function ‘main’:
f.c:3:10: warning: implicit declaration of function ‘f’ [-Wimplicit-function-declaration]
    3 |   return f();
      |          ^

**** 例 : プロトタイプ宣言
int f(void); /* プロトタイプ宣言 */

int main(void)
{
  return f();
}

int f(void) /* 関数定義 実装部分 */
{
  return 1;
}

$ gcc -Wall prototype.c 

**** ヘッダファイル
ヘッダファイル(*.h)にはプロトタイプ宣言が記述されています。
includeには、入れるや含めるという意味があります。これまで記述していた#include <stdio.h>は
stdio.hの内容を含めるという意味になります。含めていたのは、ものにはプロトタイプ宣言が入っています。

試しに#include <stdio.h>の行を削除すると、printfで「implicit declaration」が出ます。

** モジュール, ライブラリ


- 実行ファイルにはmain関数がただ1つだけ含まれる。
- モジュール *.c
- ライブラリ
  .oを集めて、.hを提供したもの。

  - 静的 :  .a  リンク時に実行ファイルに含まれる。
  - 共有 : .so　実行時にダイナミックリンクされて実行される。

** 仕様
「6.9.1 Function definitions」
「6.10.2 Source file inclusion」

** 問題

  1. Hello world!
     1. 「Hello, world!」と標準出力に出力するプログラムを作成しなさい。
         main関数の中からprintf関数を呼び出して構いません。

     2. 「Hello, world!」出力部分をprintHello関数として実装し、
         main関数から呼び出すようせよ。関数の型は以下の様にしなさい。

            void printHello(void)

  2. 2つの整数の和を計算するadd関数を作成し、main関数から呼び出してみなさい。

  3. 角度を度数の単位からラジアン単位に変換する関数を実装しなさい。

  4. 数値文字を受け取り整数値として返す関数を実装しなさい。
     実装にあたり以下の内容が助けになるだろう。

     1. 0から9の文字をprintfの10進表記で出力させてみよ。

     2. 出力された結果から文字と値の関係性を考えてみよ。

  5. 標準入力から文字を取得する以下の関数を使ってみよ。
     使用にあたり以下のマニュアルを確認せよ。

     $ man getchar

  6. helloworld.cのプリプロセス出力結果を確認してみよ。
     printfのプロトタイプ宣言はあるだろうか。

  7. helloworld.cから#include <stdio.h>を削除して、
     プリプロセス出力結果を確認してみよ。

* 条件分岐
** if

  処理1;

  if(x)
  {
     /* xが成立する場合、ここが実行される。*/
     処理2;
  }

  処理3;

** if〜else

  処理1;

  if(x)
  {
     /* xが成立する場合、ここが実行される。*/
     処理2;
  }
  else
  {
     /* xが成立しない場合、ここが実行される。*/
     処理3;
  }

  処理4;

** if〜else if〜 else〜else

  処理1;

  if(x)
  {
    /* xが成立する場合、ここが実行される。*/
    処理2;
  }
  else if(y)
  {
    /* xが成立しない。かつyが成立する場合、ここが実行される。*/
    処理3;
  }
  else
  {
    /* xが成立しない。かつyが成立しない場合 */
    /* 上記以外の場合、ここが実行される。*/
    処理4;
  }

  処理5;

** if〜else if
最後のelseはなくても特に文句はいわれません。
実は、最近知りました。

  処理1;

  if(x)
  {
    /* xが成立する場合、ここが実行される。*/
    処理2;
  }
  else if(y)
  {
    /* xが成立しない。かつyが成立する場合、ここが実行される。*/
    処理3;
  }

  処理4;

** switch

   switch(x)
   {
     case 定数1:
     　処理1;
       処理1-2;
       break;

     case 定数2:
       処理2;
       break;

     default:
       その他処理;
   }

** 仕様

「6.8.4 Selection statements」

** 問題

   1. 整数が偶数かどうかを判定する関数isEvenを作成せよ。

   2. 消費税を計算する関数 int calcTaxを作成せよ。
      税率は,軽減税率対象 8%, その他は10%とせよ。
      小数点の扱いは好きにしてよいものとする。

   3. 水量を管理するユーザーからの依頼(適当なでっち上げストーリーです。)

      1. ユ:管理しているタンクの水量が一定量に達した場合に警告を出してほしい。
	 
         ユーザーへの要望に応えるために、警告を発するかどうかの判定関数を
	 用意するこになった。実装してみよ。

      2. ユ:実は、タンクへは水量の入と排出の量が常に変動しており、現在だと、警告値付近で警告が頻繁に
　　　　　　　出たり止まったりする。一度警告状態となったら、ある程度水量が下がった後に警告を解除する様にしてほしい。

	 実装してみよ。


*** 関数型スタイルと再帰
変数への代入を行わないプログラミングのスタイルに関数型プログラミンがあります。

関数型言語の場合は末尾再帰がスタックを使用しないgotoになるが、
C言語の場合はそうはならないので、再帰呼出しが深くなりスタック領域を
使い果たすとプログラムが異常終了する。


**** 問題
1. 0からnまでの整数の和を求める関数

  sum(n) = n + sum(n-1)  (n != 0)
  sum(0) = 0             (n == 0)

具体的にすると

sum(10) = 10 + sum(9)
               9 + sum(8)
                   8 + sum(7)
:

2. 1からnまでの整数の積を求める関数

prod(n) = n * prod(n-1)  (n != 1)
prod(1) = 1              (n == 1)

* 繰り返し

** while

  while(継続条件)
  {
    /* 継続条件成立時 */

    /* 継続条件更新 */
  }

** for

  for(初期化; 継続条件; 継続条件更新)
  {
  }

** 仕様
「6.8.5 Iteration statements」

** 問題

  1. 掛け算九九

  2. 図形の描画
     問題を解くにあたり必要な関数は自由に実装せよ。

     1. 横棒 3指定

	***

     2. 四角形 4,2指定

	*****
	*****

     3. 直角三角形

	1. 4指定

	   * 
	   **
	   ***
           ****

	2. 4指定

             * 
            **
           ***
          ****

     4. 二等辺三角形 3指定

          * 
	 ***
        *****

     5. 平行四辺形 5指定

        *****
         *****
          *****

  3. 複利計算

     元金,年利,年数を指定して各年毎の金額表示させてみよ

  4. 標準入力から入力されたバイト数をカウントし結果を出力するプログラムを作成せよ。
     作成したプログラムの結果とwc -c の結果を比較してみよ。

* 配列
同じ種類の複数のデータをまとめたもの

** 問題

  1. 整数の配列から最大値の情報を返す関数を実装し、main関数から呼び出してみなさい。

  2. 2点間のデータの平均値で補完

     1. 2点間のデータを平均値で補完する関数を作成し、main関数から呼び出してみなさい。
     2. データを標準入力から読み出せるようにしなさい。
     3. 作成したプログラムの出力をグラフ化してみなさい。
     4. 作成すたプログラムをパイプを通して処理させてみなさい。


* 構造体,共用体
別の種類のデータを一つにまとめたもの

** 問題 
   統計データ

* ポインタ
ポインタとは、ポイントするモノ。
ポイントしているものは、メモリアドレス

変数とは?
人間は識別子が理解しやすい。
コンピュータはアドレス情報で動いている。

これまでの変数ではだめなの?
 1. これまでの変数はどこにあったのか?
 2. 1MBのデータを関数の引数で渡したとするとどうなるかを考えてみよ。

ポインタを使用することでできること。

** 問題
  1. 微分

* 修飾
* デバッガ(GDB)
* 総合
** #includeって何してるの?

** 簡易cat
** CDプレーヤーのモデル

  

