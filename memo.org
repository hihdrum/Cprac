#+title: C言語練習
#+startup: content
#+options: todo:nil

学習の流れ

* はじめに

どのようにプログラムを書くかという理解の進みに伴って、紹介されているプログラムが不可解に
感じる部分がでてくるであろう。そのような場合は、是非、思い描く形でプログラムを書き直してみてほしい。

この繰り返しがプログラムへの理解を養うだろう。

- 考えをプログラムとして記述する。

* 最初のプログラムと仕様情報

** TODO C言語開発環境の確認

#+begin_example
$ gcc --version
gcc (Ubuntu 12.3.0-1ubuntu1~23.04) 12.3.0
Copyright (C) 2022 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#+end_example

#+begin_comment
$の読み方をどのように説明すればよいだろうか。
所持しているRustの書籍を参考にしてみよう。
#+end_comment

** 最初のプログラム「Hello, world!」

最初に書くプログラムの定番であるハローワールドを作成し、実行してみましょう。

*** DONE helloworld.cの作成

適当なテキストエディタを使ってhelloworld.cを作成して下さい。中身は以下のとおりです。

#+name: helloworld
#+caption: 最初のソースコード helloworld.c
#+begin_src C :exports code :results output :tangle helloworld.c :cache yes
#include <stdio.h>

int main(void)
{
  printf("Hello, world!\n");
  return 0;
}
#+end_src

#+RESULTS[4741b105d0ea1c236aa0ab8a97c2697f2d670e55]: helloworld
: Hello, world!

#+RESULTS:

プログラム(ソースコード)を記述したこの様なファイルをソースファイルと言います。

*** DONE helloworld.cのビルド

ソースファイルが作成できたら、ビルドを行いコマンドとして実行できるファイルに変換します。

#+begin_example
gcc helloworld.c
#+end_example

入力ミスがある場合は何らかのエラーメッセージが出力されます。
その場合は、[[helloworld]]のソースコードと自身で入力したソースコードをよく比較してみてください。

  - スペースは半角を使用する。

異常などが出力されていない場合はコンパイルが成功しています。
a.outというファイルができているので、以下の様に実行します。

#+begin_example
./a.out
Hello, world!
#+end_example

画面に「Hello, world!」は出力されましたでしょうか。
a.out以外のファイル名にしたい場合は、はオプション-oを使用します。

#+begin_example
gcc helloworld.c -o helloworld
ls helloworld
helloworld
#+end_example

** TODO 実行ファイルができるまでの各工程

テキストファイルから実行可能なファイルになるまでは以下のように
複数の工程に分かれています。

1. プリプロセス(ヘッダファイルの処理など)
   #+begin_example
   $ gcc -E helloworld.c
   #+end_example

2. コンパイル(.c -> .S)(アセンブラ)
   #+begin_example
   $ gcc -S helloworld.c
   #+end_example

3. アセンブル(.c -> .o)(オブジェクトファイルの生成)
   #+begin_example
   $ gcc -c helloworld.c
   #+end_example
   
4. リンク
    自分もよくわかっていないので、詳しくは説明できませんが、オブジェクトファイルを実行形式に合わせて、
    結合するなど処理が行われます。白状しますと、リンクの具体的な動作は私もわかりません。

これらの工程は最初のうちはそこまで気にする必要がありません。

たいていは、gccまたは、gcc -cの使用で十分と思います。
上記のオプションはgccのマニュアルにも記載があり、ヘルプオプション(gcc --help)でも確認できます。

以下のコマンドを実行し、実際に確認してみて下さい。

#+begin_example
$ man gcc
$ gcc --help
#+end_example

マニュアルとヘルプにはアセンブラへの変換をコンパイルと記述されています。
現場における個人的な印象ですが、会話の中では実行ファイルの作成までをコンパイルといったり、
オブジェクトファイルの作成までをコンパイルといったり様々です。
なので、厳密な場合でなければ話の文脈で判断することになると思います。

*** 発展:オブジェクトファイルのダンプ

オブジェクトファイルの情報はobjdumpコマンドで見ることができます。

#+begin_example
$ gcc -c helloworld.c
$ objdump -d helloworld.o 

helloworld.o:     ファイル形式 elf64-x86-64


セクション .text の逆アセンブル:

0000000000000000 <main>:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # f <main+0xf>
   f:	e8 00 00 00 00       	callq  14 <main+0x14>
  14:	b8 00 00 00 00       	mov    $0x0,%eax
  19:	5d                   	pop    %rbp
  1a:	c3                   	retq 
        ^^^^^^^^^^^^^^^^^^^^^^  ^^^^アセンブラ
        マシン語
#+end_example

-dはディスアセンブルオプションとなっています。左の部分はCPUが理解するマシン語の命令になっています。
例えば、オフセット4の0x55は「push %rbp」の命令に対応していことになります。

極端な話をすれば、バイナリエディタで、main部分に出力された内容のデータを作成したものと、gccによって出力された
上記のデータが同じであればmainは同じ動きをします。

** 仕様情報

私はこれまでC言語の仕様を気にしてコードを書いたことはありませんが、この機会に情報を探してみました。
私の環境ではGCCを使用しており、バージョンを以下の用に確認すると9.3.0でした。

#+begin_example
$ gcc --version
gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#+end_example

:メモ:
古い情報になっているので、現在使用している環境の値に置き換わるような仕組みにしたい。
:END:

gccのinfoを見ると「2.1 C Language」には、仕様C11にGNUの拡張を加えたものがデフォルトの
動作になっていると記載がありました。

#+begin_quote
  The default, if no C language dialect options are given, is
  '-std=gnu17'
#+end_quote

仕様のドラフト版は以下からダウンロードできるのでダウンロードしてみて下さい。

　　仕様のドラフト

　　  ISO C Working Group (http://www.open-std.org/jtc1/sc22/wg14/)
　　    9899: Programming Language C
　　      C11	ISO/IEC 9899:2011	N1570 [2011-04-04]

N1570のリンクからN1570.pdfが取得できます。

:メモ:
C17の情報に置き換える。
org-modeのリンク機能も活用したい。
:END:

** プログラムの終了ステータスの取得

シェルは最後に実行したプログラムの終了ステータスを~$?~に持っており、echoコマンドで値を確認することができます。
この節では自作したプログラムの終了ステータスを確認してみます。

自作のプログラムの終了ステータスについて確認する前に、幾つかの既存コマンドの終了ステータスを確認します。

*** DONE 既存コマンドの終了ステータスの確認

true, falseコマンドを例に~$?~の実行結果を確認してみましょう。
まずは、以下のコマンドでtrueとfalseのマニュアルを確認して下さい。

#+begin_example
$ man true
$ man false
#+end_example

マニュアルの関連項目には完全なマニュアルはTexinfoマニュアルとして整備されていると記載があります。
以下のコマンドで確認してみてください。

#+begin_example
$ info true
$ info false
#+end_example

infoによるとtrueは、成功を意味する0を返し、falseは失敗を意味する1を返すと記載されています。

実際にtrue, falseコマンドを実行しマニュアルに記載された通りの終了ステータスが得られることを
確認してみます。

#+name: trueの終了ステータス
#+begin_src shell :exports both :cache yes
true; echo $?
#+end_src

結果は以下のようになります。

#+RESULTS[f52d9371b0303e5998357ceb591fab583f49f0c3]: trueの終了ステータス
: 0

falseコマンドも同じように確認してみます。

#+name: falseの終了ステータス
#+begin_src shell :exports both :cache yes
false; echo $?
#+end_src

#+RESULTS[2e6f0f8c253db5b8e94c4d534f74797c1a9bc1c0]: falseの終了ステータス
: 1

**** DONE 練習 : grepコマンドの終了ステータス確認

tureやfalseの他にgrepコマンドなども成功と失敗を返しています。
grepのマニュアルを参照し、どの様な終了ステータスを返すのかを確認してみて下さい。

#+begin_example
man grep
#+end_example

マニュアルには選択行が見つかった場合は0, 見つからなかった場合は1と記載があります。
見つかる場合と見つからない場合の2ケースを実際に試し終了ステータスを確認して下さい。

#+name: grep終了ステータス正常
#+begin_src shell :exports both :results output :cache yes
echo abc | grep a; echo $?
#+end_src

#+RESULTS[6d62498256c5294bb42f300ac4d0f33255506e9e]: grep終了ステータス正常
: abc
: 0

#+name: grep終了ステータス失敗
#+begin_src shell :exports both :results output :cache yes
echo abc | grep d; echo $?
#+end_src

#+RESULTS[4f4d7dcc1952a6905f6921000bb3846ce4e3bcba]: grep終了ステータス失敗
: 1

*** DONE 終了ステータスを返すだけの小さなプログラム

C言語では、main関数の戻り値(return 0 の 0)がプログラムの終了ステータスとなります。

helloworld.cでは画面に文字列を出力(printf)するために、おまじない(#include <stdio.h>)を記述しました。
実はこのおまじないは、画面出力(printf)を使用するために記述しています。プログラムの終了ステータスを返すだけの場合は、
画面出力(printf)が不要なので、このおまじないを取り除くことができます。

以下のreturn0.cを作成し実行させてみなさい。

#+name: return0
#+begin_src c :exports code :tangle return0.c
  int main(void) {
    return 0;
  }
#+end_src

#+name return0のビルドと動作確認
#+begin_src shell
  gcc -Wall return0.c
  ./a.out
  echo $?
#+end_src

#+RESULTS:
: 0

このプログラムは--helpや--versionのオプションを受け取れませんが、trueコマンドと同じです。

**** DONE 練習 常に1を返すプログラムの作成と動作確認

常に失敗の終了ステータス1を返すプログラムをmyfalse.c作成し、動作を確認してみなさい。

#+caption: myfalse.c
#+name: myfalse
#+begin_src C :exports code :tangle myfalse.c
  int main(void) {
    return 1;
  }
#+end_src

#+name: myfalseのビルドと動作確認
#+begin_src shell
  gcc -Wall myfalse.c
  ./a.out
  echo $?
#+end_src

#+RESULTS: myfalseのビルドと動作確認
: 1

** プログラム

C言語の様な手続き型言語のプログラムは平たく言えば、逐一やること書いたものの並びと考えてよいです。
注意点として、コンピュータは基本的に忖度しないので、良きに計らうことが無いので、本当に逐一書くことになります。

最近は、スマホなどのように非常に直感的に動作するものがありますが、高度なプログラミングの集積の上に成り立っていると
考えた方がよいでしょう。

プログラムの記述についてエドガー・ダイクストラが提唱した構造化3定理というものがあります。

  - 順次実行
  - 条件分岐
  - 繰り返し

プログラムの要素はつまるところ、上記の3つで記述できるというものです。

*** TODO 発展:XX指向プログラミング
現在の主流のプログラミングは手続き型で作成されていると考えてよいでしょう。
個人的には、各種言語が関数型の考え方を取り入れて進化していっているという印象を持っています。

世の中には、「XX指向プログラミング言語」という言葉をよく聞いたり、見たりしますが、意味合いとしては
「XX指向プログラミンをサポートする言語」という理解が良いと思います。

XX指向プログラミング言語でプログラムを記述したから、XX指向になるは多くの場合成立しません。
逆を言えば、XX指向プログラミンをサポートシしていない言語でもXX指向のプログラミンは行うことができます。
ただ、言語的なサポートが無いのでサポートしている言語に比べて記述は、しにくくなります。

　- 宣言的
    - 関数型 : Haskell, Erlang(アクター指向)
    - 論理型 : Prolog
    - 手続き的
      - アセンブラ, C
    - オプジェクト指向
      - Smalltalk
    - プロトタイプ指向
      - Javascript, io, 
    - マルチパラダイム
      - Lisp, Java, C++, ...

** DONE 順次実行

C言語は素直に上から下に順次実行されてきますので、処理を上から下に並べて記述すれば順次実行されます。
以下のプログラムを作成し、実際に動作させてみなさい。

#+name: 順次実行
#+begin_src C :exports both :results output :tangle junn.c :cache yes
  #include <stdio.h>

  int main(void) {
    printf("最初\n");
    printf("次\n");

    return 0;
  }
#+end_src

実行してみると、記述した順序の通り、"最初"が画面に出力され、次に"次"が出力されます。

#+RESULTS[49bd875510538036b2a84413a7f89847afd3d560]: 順次実行
: 最初
: 次

** 問題
*** DONE 計算結果を終了ステータスとして返すプログラム(prac02.c)

1 + 2 の計算結果を終了ステータスとして返すプログラムを作成しなさい。
プログラムで計算を行わせるようにし、計算結果の3をプログラム中に埋め込まないようにせよ。

#+begin_src C :tangle prac02.c
  int main(void) {
    return 1 + 2;
  }
#+end_src

#+name: prac02実行結果
#+begin_src shell
  gcc -Wall prac02.c -o prac02
  ./prac02; echo $?
#+end_src

#+RESULTS: prac02実行結果
: 3

*** DONE 整数の和を終了ステータスとして返すプログラム(returnWa1to10.c)

1から10までの整数の和を終了ステータスとして返すプログラムを作成しなさい。
まだ、変数、条件文、繰り返し、再帰などプログラミングに関することを何も説明していないが、
プログラミングを電卓への入力の延長として考えてみよ。

つまりは、電卓を使って、1から10までの和を足し算で求めることができるなら、
同じようにできるはずである。

#+begin_src C :tangle returnWa1to10.c
  int main(void) {
    return 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10;
  }
#+end_src

#+name: returnWa1to10の実行結果
#+begin_src shell
  gcc -Wall returnWa1to10.c -o returnWa1to10
  ./returnWa1to10; echo $?
#+end_src

#+RESULTS: returnWa1to10の実行結果
: 55

*** DONE gccのマニュアル-Wallオプション

gccの-Wallオプションについてマニュアルを調べてみよ。
このオプションは警告を出力してくれるので積極的な利用を進める。

#+begin_src shell
  man gcc
#+end_src

gccの-Wallオプションについてinfoを調べてみよ。

#+begin_src shell
  info gcc
#+end_src

この問題は、書いていることが分からなくともまずは、manやinfoの情報にあたってみてほしい欲しいという
思いからのものである。

*** 画面への文字列の出力

画面に文字列を出力するプログラムを作成し、文字列が上下左右のどこからどこに向かって出力されていくのかを
意識して見てみよ。

画面に以下のような文字列を出力するプログラムhello2を作成しなさい。

#+begin_example
hello
hello
#+end_example

#+name: hello2_01
#+begin_src C :results output :tangle hello2.c :cache yes
  #include <stdio.h>

  int main(void) {
    printf("hello\n");
    printf("hello\n");

    return 0;
  }
#+end_src

#+RESULTS[d1606336989156bcd63ffd8785d2764a71ff3320]: hello2_01
: hello
: hello

別の書き方はあるだろうか。

#+name: hello2_02
#+begin_src C :results output :tangle hello2.c :cache yes
  #include <stdio.h>

  int main(void) {
    printf("hello\nhello\n");

    return 0;
  }
#+end_src

小さな例ではあるが、プログラムの実装方法は1つではない。
できるだけわかりやすいほうがよいだろう。

#+RESULTS[f94146d71f6463cc01a3e0b2d36a1c74aff73e23]: hello2_02
: hello
: hello

画面に以下のような文字列を出力するプログラムhello3を作成しなさい。

#+begin_example
hello
 hello
  hello
#+end_example

#+begin_src C :results output :cache yes
  #include <stdio.h>

  int main(void) {
    printf("hello\n");
    printf(" hello\n");
    printf("  hello\n");

    return 0;
  }

#+end_src

#+RESULTS[274011f5270177e9032a2bbb1c5684aa071b88f2]:
: hello
:  hello
:   hello

画面に以下のような文字列を出力するプログラムtreeを作成しなさい。

#+begin_example
    *
   * *
  *   *
 *     *
*********
    *
    *
#+end_example

#+begin_src C :results output
  #include <stdio.h>

  int main(void) {
    printf("    *\n");
    printf("   * *\n");
    printf("  *   *\n");
    printf(" *     *\n");
    printf("*********\n");
    printf("    *\n");
    printf("    *\n");

    return 0;
  }
#+end_src

#+RESULTS:
:     *
:    * *
:   *   *
:  *     *
: *********
:     *
:     *

*** 9. (質問からの問題) gccによってビルドしたファイルに実行件が付与されていることについて

以下のような質問があった。

#+begin_quote
シェルスクリプトなどのファイルを実行可能にする場合、chmodコマンドで実行件(x)を付与するが、
gccでソースファイルをビルドすると最初から実行可能になっています。
なぜですか?
#+end_quote

**** 予想 : chmodコマンドが実行されているのではないか?

最初にchmodコマンドが実行ファイルができるまでのどこかの工程で実行されているかもしれない。と予想を立てた。
プログラムには通常出力しない実行時の詳細情報を出力するオプションを用意している場合がある。

gcc に詳細情報を出力する -v または -verbose オプションがあるかをマニュアルから調べてみよ。
また、オプションが存在した場合、実際に使用し質問の回答になるかを確かめてみよ。

**** chmodコマンドが行っていることは?

(関数の後に取り組んだ方がよい)

gccはchmodコマンドを呼び出していないようだが、chmodが行っている「ファイルのモードを変更する」という処理と
同じ処理を行っているのではないか。と予想を立てた。この「ファイルのモードを変更する」というchmodコマンドの
機能は何によって実現されているのだろうか。

chmodのマニュアルを参照してみよ。特に「関連項目」について見てみよ。

**** chmodシステムコール

関連項目の情報から「ファイルのモードを変更する」という機能はchmodシステムコールにより提供されていることが
わかった。つまり、chmodコマンドは、chmodシステムコールを指定したファイルに指定したモードで呼び出すためのコマンドと
見ることができる。

システムコールをトレースするコマンドstraceがある。straceを使用しchmodシステムコールによって
実行権が付与されているかを確認してみよ。

この資料において、システムコールは関数呼び出しと同じであると考えてよい。

* 変数

変数は、計算結果を一時的に保存する際のメモの様な物です。
メモには値を書き込むことで保存できたり、保存した値をメモから読み込んだりできます。

変数は宣言時に名前(識別子)を付けます。
名前があるおかげで、名前を指定して値を書き込んだり、

** DONE 変数の宣言

変数を使用する際は予め宣言しておく必要があります。
変数を宣言するには以下のようにします。

#+name: 変数の宣言
#+begin_src C
  保持したい型の情報 名前(識別子);
#+end_src

例えば、int型の変数をxという名前で宣言する場合は以下のようになります。

#+name: int型変数xの宣言例
#+begin_src C
  int x;
#+end_src

** DONE 変数への書き込み

変数に値を書き込む場合は、代入(~=~)を使用します。

#+begin_src C
  x = 10;
#+end_src

** DONE 変数からの読込み

変数に書き込んだ値を読み込む場合は単に名前を指定します。

#+name: 変数からの読み込み
#+begin_src C
  int x = 10;
  printf("%d\n", x);
#+end_src

#+RESULTS: 変数からの読み込み
: 10

** DONE 変数の宣言と初期化

変数を宣言する際に初期値を指定すると、指定した値で初期化されます。

#+name: 変数の宣言と初期化
#+begin_src C
  保持したい型の情報 名前(識別子) = 初期値;
#+end_src

#+name: 変数の宣言例
#+begin_src C
  int  x = 10;
#+end_src

[[変数の宣言]]とほぼ違いがありませんが、constで変数を読込み専用にする場合は、宣言時に初期化しなければ、
値を変更することができなくなります。

#+begin_comment
constの例は問題に移動してもよいかも。
#+end_comment

#+name: constの使用例ok
#+begin_src C
  const int ten = 10;
  printf("%d\n", ten);
#+end_src

#+RESULTS: constの使用例ok
: 10

constで指定した値に書き込みを行おうとするとコンパイルエラーとなります。

#+name: constの使用例コンパイルエラー
#+begin_src C
  const int ten;
  ten = 10;
  printf("%d\n", ten);
#+end_src

#+begin_comment
コンパイルエラーを貼り付けたほうが良いかも。
#+end_comment

** 変数の宣言例

宣言例は以下となります。

#+begin_src C
  int weeknum = 7;    /* 一週間の日数 */
  double pi   = 3.14; /* 円周率(小数点2桁まで) */
  char good   = 'A';  /* 評価 */ /* 文字を記述する場合はクォート(')で囲見ます。*/
#+end_src

C言語は型を意識する言語になっています。
型の情報はメモリ領域の確保や、異なる型の演算をユーザーが誤って記述している場合などのチェックに使われています。
型や変数が使用するメモリ領域のサイズはsizeof(型)やsizeof(変数名)で取得できます。結果はバイト単位です。

*** DONE 整数型 int

1週間の日数を保持するint型の変数を使用する以下のプログラムを作成し、実行してみなさい。

#+name: int型変数の例
#+begin_src C :results output :tangle use_int.c
  #include <stdio.h>

  int main(void) {

    int weeknum = 7; /* 一週間の日数 */
    printf("weeknum = %d\n", weeknum);

    printf("sizeof(int) = %zd\n", sizeof(int));
    printf("sizeof(weeknum) = %zd\n", sizeof(weeknum));

    return 0;
  }
#+end_src

#+RESULTS: int型変数の例
: weeknum = 7
: sizeof(int) = 4
: sizeof(weeknum) = 4

#+name: int型変数使用の実行例
#+begin_src shell :results output
  gcc -Wall use_int.c -o use_int
  ./use_int
#+end_src

#+RESULTS: int型変数使用の実行例
: weeknum = 7
: sizeof(int) = 4
: sizeof(weeknum) = 4

**** TODO 問題1

use_int.cは初期値を指定した変数の宣言方法であった。
初期値を指定しない場合、変数の値に何か入っているかを確認するプログラムをuse_int.cを参考に作成しなさい。

**** 問題2

int型には他にshort int, long intなどの型がある。これらの型の変数について、サイズを確認してみよ。

*** 文字型 char

文字を保持するchar型の変数を使用する以下のプログラムを作成し、実行してみなさい。

#+name: char型変数の例
#+begin_src C :results output :tangle use_char.c
  #include <stdio.h>

  int main(void) {
    char a = 'a';
    printf("a = %c\n", a);

    printf("sizeof(char) = %zd\n", sizeof(char));
    printf("sizeof(a) = %zd\n", sizeof(a));

    return 0;
  }
#+end_src

#+RESULTS: char型変数の例
: a = a
: sizeof(char) = 1
: sizeof(a) = 1

#+begin_src shell :results output
  gcc -Wall use_char.c -o use_char
  ./use_char
#+end_src

#+RESULTS:
: a = a
: sizeof(char) = 1
: sizeof(a) = 1

文字型という型ですが、sizeof(char)の結果を見るようにサイズは1バイトです。
そのため、多バイト文字を扱おうとするとコンパイル時に警告が出ます。
1バイトサイズの変数を保持する型と保持する型と覚えればいいでしょう。

*** 実数型 float
実数値を保持するfloat型の変数を使用する以下のプログラムを作成し、実行してみなさい。

#+NAME: var_float.c
#+BEGIN_SRC C
#include <stdio.h>

int main(void)
{
  float f = 1.142;
  printf("f = %f\n", f);

  printf("sizeof(float) = %zd\n", sizeof(float));
  printf("sizeof(f) = %zd\n", sizeof(f));

  return 0;
}
#+END_SRC

#+RESULT: var_float.c
$ gcc -Wall var_float.c -o var_float
$ ./var_float 
f = 1.142000
sizeof(float) = 4
sizeof(f) = 4

C言語では整数と実数はメモリ上の表現が異なりますので、1と1.0の扱いは異なります。

**** 問題
1. float型の変数に整数値を代入するプログラムを作成しなさい。
2. int型の変数に実数値を代入するプログラムを作成しなさい。
3. printfでは整数型を指定する場合%d, 実数型を指定する場合%fを使用してきたが、
   整数型の変数を%fで、実数型を%dで出力させてみよ。
4. 変数の前に(型)変数と記述することでコンパイラに型を強制することができ、キャストという。
   キャストを使用し、警告がでなくなることを確認せよ。
5. printfの精度オプションを使用し小数点2桁表示で実数型の値を出力させてみよ。

***** 問題3について(C言語の学習とは関係ない領域)
問題3の説明にて%d,%fでprintfのメモリ解釈が変わるため結果が変わると説明したが、
次の質問がでた。メモリの解釈が変わるだけならば、実行時にメモリ内容は指定しているので、
実行のたびに値は変化しないはずだ。実行のたびに値が変化しているので、確かに指摘のとおりである。

結論としては、printfは%f指定時にはxmmに指定した値を元に出力データを得ており、
%d指定時にはesiを元に出力データを得ているようであった。そのため、%d指定で、
float型の変数を渡した場合、printfはesiの情報を参照する。オブジェクトコードを
見ると、printfの呼び出し前にesiへの操作は無かった。つまり、esiにはゴミ情報が
入っていることになる。そのため、実行のたびに値が変化していた。

調査にあたって確認したもの。
  1. gccにより生成されたオブジェクトコードの確認
  2. 以下のパターンの比較
     1. %d に float型
     2. %f に float型
     3. %d に int型

** 配列
C言語には配列というデータ構造た用意されており、同じ様なデータを扱うのに利用できます。
以下の様に記述します。

  保持したい型の情報 名前(識別子)[要素数] = { 値1, 値2, ... };
              int ia[3] = { 1, 2, 3 };

配列の場合も値を指定せずに宣言することができます。

  保持したい型の情報 名前(識別子)[サイズ];
              int ia[] = { 1, 2, 3 };

例

  float weights[3] = { 55.5, 60.0, 70.2 } /* 3つの体重 */
  char hello[] = { 'H', 'e', 'l', 'l', 'o', '\0'} /* 文字列Hello */ /* '\0' は文字列の終端 */
  char hello2[] = "Hello"; /* 上と同じ */ /* 文字列はダブルクォート(")で囲む */

保持した情報へのアクセス時は0オリジン(0から数え始める)で[]の中に場所を整数値で指定します。
この整数値のことを、添え字やインデックスといいます。

  weighs[0]  <-- 55.5

指定範囲外へのアクセスはプログラムの異常動作に繋がりますので、注意しましょう。

*** int型の配列
int型の配列を使用する以下のプログラムを作成し、実行してみなさい。

#+NAME: array_int.c
#+BEGIN_SRC C
#include <stdio.h>

int main(void)
{
  int score[3] = { 10, 19, 17 };

  printf("score[%d] = %d\n", 0, score[0]);
  printf("score[%d] = %d\n", 1, score[1]);
  printf("score[%d] = %d\n", 2, score[2]);

  printf("sizeof(score) = %zd\n", sizeof(score));

  return 0;
}
#+END_SRC

#+RESULT: array_int.c
$ gcc -Wall array_int.c -o array_int
$ ./array_int 
score[0] = 10
score[1] = 19
score[2] = 17
sizeof(score) = 12

**** 問題
1. int型、要素数3の配列を宣言し、最初の2要素だけ初期化した場合、3番目の要素(インデックス2)にどの様な値が
   入っているかを確認するプログラムを作成せよ。
2. char型の配列helloを宣言し以下の様にデータを設定し、内容を出力させてみよ。(prac02.c)
   番目 : データ
     0 : 'H'
     1 : 'e'
     2 : 'l'
     3 : 'l'
     4 : 'o'
     5 : '\0'
3. 上記のプログラムに変換指定子%sを使用するprintfを追加しhelloを出力させてみよ。

** 紹介していない型
「6.7.2 Type specifiers 2」

** printf
printfは画面にプログラムの情報を出力するのに使うことができます。
学び始めの段階では、実際のプログラムの動作と自分の頭のプログラム動作とが一致しないことが多くあります。
その際、処理の間にprintfを挿入し状況を見ていくというのはプログラムの理解を助けます。

実業務でプログラムを書くようになっても自分の頭とプログラムの動作が一致しないことは日常的に起きます。
つまりは、バグを入れ込んだということです。

慣れてくると、printfではなくデバッガを使ってプログラムの動作を確認する方法を取ることもありますが、
どちらの方法をとるかは状況によります。printfの出力に慣れていて損はないので、ぜひ色々と出力させてみて下さい。

*** マニュアル
printfのマニュアルを以下の様に調べるとpritfコマンドについての内容が出てきます。

$ man printf

この様な場合はセクション情報も指定します。

$ man 3 printf

各セクションの情報はmanコマンドのマニュアルで確認できます。
C言語での開発時によく見るのは以下のセクションとなります。

       2   システムコール (カーネルが提供する関数)
       3   ライブラリー呼び出し (プログラムライブラリーに含まれる関数)

インフラ系の人はセクション5のお世話になっているかもしれないですね。(man  hostsなど)

       5   File formats and conventions, e.g. /etc/passwd

** コメント
ソースコード中にはプログラムの動作に影響しないメモとしてコメント記述することができます。

学習時にはプログラムの動作をメモしてみるというのも一つの方法かもしれません。
コメントについては格言もあり、「書かれしことを書くな。書かざれしことを書け」というものがあります。
プログラムが語っている動作をコメントに書く必要は無い。しかし、プログラムが語れないことはコメントとして
書くべきとの格言です。

*** 1行コメント
   // ........

*** 複数行対応
   /* xxxxxx */

   /* 
      aaaaaa
      zzzzzz
    */

*** その他
プリプロセスを利用した例

#if 0

  #if から #endif までのコードが無効になります。

#endif

*** 仕様

「6.4.9 Comments」も合わせて参照してみて下さい。

* 関数
関数(function)には、機能や働きという意味があります。C言語における関数も同じで機能や働きを実現するために使用します。
例えば、printf関数は、指定された書式(f:format)で出力(print)する機能を持っています。

** 関数と抽象化
関数の利点のひとつに指定された使い方を守れば、その機能を利用できるという点があります。
利用にあたっては、関数がどの様に実装されているかは気にする必要がありません。

実生活の中ではこの様なものが多くあります。
例えば、洗濯機ではどのように洗濯するかをボタンで選んでスタートを押せば、洗濯をしてくれます。
利用者は洗濯機が洗濯槽のモーターの電流をどの様に制御しているかは普通知らないと思いますが、洗濯機は使えているはずです。

これは、一種の抽象化といえます。具体的なレベルではモーターの電流などを考えなければいけませんが、
幾つかの回路などを組みあせて、モータ制御部が組み上がり、抽象度が上がっていき、最終的にボタン入力で洗濯ができる。という
段階まできているわけです。

関数を定義していくことは抽象化の層を作っているという感じです。

抽象度高 <----> 抽象度低
洗濯する。
  ボタン入力で洗濯メニューをコントロールする。
    指定メニューに合わせて洗濯機の動作を制御する。
      指定の水位まで水をいれる。
        水の流入口を開く。
      モータの回転を制御する。
        時間経過で逆回転にする。
  :

** 関数定義
戻り値の型 関数名(引数の型 引数の名前)　/* プロトタイプ宣言に使用する部分 */
{
  各種処理;

  return 戻り値;
}

引数が不要な場合はvoidを記述します。
戻り値が不要な場合は戻り値の型を void とします。
戻り値の型がvoidの場合はreturnを省略できます。または、return;とします。

これまで記述したmain関数を見直し見ると上記の形式にちゃんと合っています。

以下はint型の引数に1を加えて返す関数の例である。実際に記述し実行してみよ。

#+NAME: add1.c
#+BEGIN_SRC C
#include <stdio.h>

int add1(int x)
{
  return x + 1;
}

int main(void)
{
  int x = 10;
  printf("x + 1 = %d\n", add1(x));

  int x1 = add1(x);
  printf("x1 = %d\n", x1);

  return 0;
}
#+END_SRC

#+RESULT: add1.c
$ gcc -Wall add1.c -o add1
$ ./add1 
x + 1 = 11
x1 = 11

*** 問題
**** DONE float型の引数を受け取り、その値の2乗を返す関数square_floatを作成し、実際に使用してみよ。

#+name: square_floatの利用
#+begin_src C :tangle use_square.c
  float square_float(float x) {
    return x * x;
  }

  int main(void) {
    float x = 2.0;

    printf("square_float(%f) = %f\n", x, square_float(x));

    return 0;
  }
#+end_src

#+RESULTS: square_floatの利用
: square_float(2.000000) = 4.000000

**** DONE float型の引数を受け取り、その値の3乗を返す関数cube_floatを作成し、実際に使用してみよ。

作成にあたり、square_floatを利用せよ。

#+name: cube_floatの利用
#+begin_src C :tangle use_cube.c
  float square_float(float x) {
    return x * x;
  }

  float cube_float(float x) {
    return x * square_float(x);
  }

  int main(void) {
    float x = 2.0;

    printf("cube_float(%f) = %f\n", x, cube_float(x));

    return 0;
  }
#+end_src

#+RESULTS:
: cube_float(2.000000) = 8.000000

**** DONE float型の引数を受け取り、その値の4乗を返す関数quad_floatを作成し、実際に使用してみよ。

作成にあたり、square_floatを利用せよ。

#+name: quad_floatの利用
#+begin_src C :tangle use_quad.c
  float square_float(float x) {
    return x * x;
  }

  float quad_float(float x) {
    return square_float(square_float(x));
  }

  int main(void) {
    float x = 2.0;

    printf("quad_float(%f) = %f\n", x, quad_float(x));

    return 0;
  }
#+end_src

#+RESULTS: quad_floatの利用
: quad_float(2.000000) = 16.000000

**** DONE 2つの整数の和を計算する関数addを作成し実際に使用してみよ。(add.c)

#+name: addの利用
#+begin_src C :tangle add.c
  #include <stdio.h>

  int add(int x, int y) {
    return x + y;
  }

  int main(void) {
    int x = 5;
    int y = 10;

    printf("%d + %d = %d\n", x, y, add(x, y));

    return 0;
  }
#+end_src

#+RESULTS: addの利用
: 5 + 10 = 15

**** DONE Hello, world!と画面に出力する関数printHelloを作成しなさい。

#+begin_src C :results output :tangle use_printHello.c :cache yes
  #include <stdio.h>

  void printHello(void) {
    printf("Hello, world!\n");
  }

  int main(void) {
    printHello();
    return 0;
  }
#+end_src

#+RESULTS[4ddd53710e2cfdc799c2d810b172a0ee0fd14e2b]:
: Hello, world!

*** プロトタイプ宣言

C言語ではファイルの先頭側で定義した関数1からファイルの後の方で定義した関数2を使用すると、
コンパイル時に警告:暗黙の型宣言がでます。これは、関数1のコンパイル時に関数2の型情報が無いために、
コンパイラが「型の情報が無いのでわかりません〜」と言っているわけです。

この様な問題を回避するため、関数の型情報をプロトタイプ宣言としてファイルの先頭の方に記述します。
プロトタイプ宣言は関数定義の一部を記述します。

以下は実際に暗黙の型宣言(implicit declaration)の警告を出力させた例です。
実際に記述し実行してみよ。

#+NAME: 暗黙の型宣言
#+begin_src C
int main(void)
{
  return f();
}

int f(void)
{
  return 1;
}
#+end_src

#+begin_example
$ gcc -Wall implicit.c 
implicit.c: In function ‘main’:
implicit.c:3:10: warning: implicit declaration of function ‘f’ [-Wimplicit-function-declaration]
    3 |   return f();
      |          ^
#+end_example

以下はプロトタイプを宣言(プロトタイプ宣言)したことで、暗黙の型宣言の警告がでなくなった例です。
実際に記述し実行してみよ。

#+NAME: prototype.c
#+BEGIN_SRC C
int f(void); /* プロトタイプ宣言 */

int main(void)
{
  return f();
}

int f(void) /* 関数定義 実装部分 */
{
  return 1;
}
#+END_SRC

#+RESULT: prototype.c
$ gcc -Wall prototype.c 

*** ヘッダファイル
ヘッダファイル(*.h)にはプロトタイプ宣言が記述されています。
includeには、入れるや含めるという意味があります。これまで記述していた#include <stdio.h>は
stdio.hの内容を含めるという意味になります。含めていたのは、ものにはプロトタイプ宣言が入っています。

試しに#include <stdio.h>の行を削除すると、printfで「implicit declaration」が出ます。

**** 問題
***** Hello, world!と画面に出力するプログラムを作成しなさい。
出力にはprintf関数を使用せよ。

***** STARTED 作成したプログラムから#include <stdio.h>を削除し暗黙の型宣言の警告が出力されるか試してみなさい。(hello_imp.c)

#+begin_src C :tangle hello_imp.c
  int main(void) {
    printf("Hello, world!\n");
    return 0;
  }
#+end_src

#+begin_src shell
  gcc -Wall hello_imp.c
#+end_src

***** stdio.hからprintfに関するプロトタイプ宣言を抜き出すとどうなるだろうか。試してみなさい。(hello_prot.c)

** モジュール, ライブラリ

- 実行ファイルにはmain関数がただ1つだけ含まれる。
- モジュール *.c
- ライブラリ
  .oを集めて、.hを提供したもの。

  - 静的 :  .a  リンク時に実行ファイルに含まれる。
  - 共有 : .so　実行時にダイナミックリンクされて実行される。

** 仕様
「6.9.1 Function definitions」
「6.10.2 Source file inclusion」

** 問題
1. 角度を度数の単位からラジアン単位に変換する関数を実装しなさい。(deg2rad.c)
   円周率は、math.hのM_PIを使用しなさい。

2. mathライブラリのfloat powf(float x, float y)の結果を利用し、2,3,4乗を計算させてみよ。
   前の問題でXXXX_float関数を実装済なら計算結果を比較してみよ。

3. 数値文字を受け取り整数値として返す関数を実装しなさい。(deg2rad.c)
   実装につまる場合は以下を試してみなさい。

   1. 0から9の数字文字をprintfの10進表記で出力させてみよ。

   2. 出力された結果から文字と値の関係性を考えてみよ。

4. 標準入力から文字を取得する以下の関数を使ってみよ。(getchar.c)
   使用にあたり以下のマニュアルを確認せよ。

   $ man getchar

* 条件分岐

これまでのプログラムは関数の呼び出しはあるものの、実行順序は基本的に上から下への流れでした。
ここからは、順次実行に加えて構造化3定理の条件分岐を加えていきます。

条件分岐とは、条件が成立した場合だけ、処理を行う。というように処理を行うかどうかを制御する能力のことです。
出かける際に傘を持参するかどうかを判定する例を考えてみます。

  1. 天気予報を確認する。
  2. 天気予報の降水確率が75%以上かどうかを確認する。
  3. 75%以上の場合、傘を持つ。
  4. 75%未満の場合、傘は持たない。

という様に傘を持つかどうかを天気予報で変えたりしていると思います。
2の降水確率の結果によって、3または4に処理が分かれる部分がこれまでのプログラムとの違いとなります。

最初に条件判定に利用する演算子に付いて練習した後に、処理が分岐するプログラムを記述してみます。

** 条件判定に利用する演算子

#+name: eop01
#+begin_src C :results output :tangle eop01.c
#include <stdio.h>

int main(void)
{
  int x = 1;
  int y = 1;
  printf("(%d == %d) = %d\n", x, y, x == y);

  y = 2;
  printf("(%d == %d) = %d\n", x, y, x == y);

  return 0;
}
#+end_src

#+RESULTS: eop01
: (1 == 1) = 1
: (1 == 2) = 0

*** 仕様
「6.5.9 Equality operators」

*** 問題

1. 「6.5.9 Equality operators」には、等しいかどうかを判定する==の他に、
    等しくないことを判定する!=が記載されている。!=を実際に使用してみよ。

2. 「6.5.8 Relational operators」には、大小関係を判定する一連の演算子について記述がある。
   1. < を実際に使用してみよ。
   2. > を実際に使用してみよ。
   3. <= を実際に使用してみよ。
   4. >= を実際に使用してみよ。

3. より複雑な判定行う場合ために、条件を組み合わせる論理積(「6.5.13 Logical AND operator」)と
   論理和(6.5.14 Logical OR operator)」が用意されている。

   1. && を実際に使用してみよ。
   2. || を実際に使用してみよ。

以下は整数を受け取り偶数かどうかを判定するプログラムの例である。
実際に記述し実行してみよ。

** 選択文

#+name: iseven
#+begin_src C :results output :tangle iseven01.c
#include <stdio.h>

int isEven(int x)
{
  int isEven = 0; /* 0:奇数, 1:偶数 */
  if(x % 2 == 0)
  {
    isEven = 1;
  }

  return isEven;
}

int main(void)
{
  int x = 5;
  printf("isEven(%d) = %d\n", x, isEven(x));

  x = 6;
  printf("isEven(%d) = %d\n", x, isEven(x));

  return 0;
}  
#+end_src

#+RESULTS:
: isEven(5) = 0
: isEven(6) = 1

** 仕様
「6.8.4 Selection statements」

** if
xが成立する場合に、処理2を実行する。

  処理1;

  if(x)
  {
     /* xが成立する場合、ここが実行される。*/
     処理2;
  }

  処理3;

** if〜else
xが成立する場合、に処理2が実行され、xが成立しない場合に処理3を実行する。

  処理1;

  if(x)
  {
     /* xが成立する場合、ここが実行される。*/
     処理2;
  }
  else
  {
     /* xが成立しない場合、ここが実行される。*/
     処理3;
  }

  処理4;

以下は整数を受け取り偶数かどうかを判定するプログラムの例である。
実際に記述し実行してみよ。

#+NAME: iseven02.c
#+BEGIN_SRC C
#include <stdio.h>

/* 0:奇数, 1:偶数 */
int isEven(int x)
{
  if(x % 2 == 0)
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

int main(void)
{
  int x = 5;
  printf("isEven(%d) = %d\n", x, isEven(x));

  x = 6;
  printf("isEven(%d) = %d\n", x, isEven(x));

  return 0;
}
#+END_SRC

#+RESULT: iseven02.c
$ gcc -Wall iseven02.c
$ ./a.out
isEven(5) = 0
isEven(6) = 1

** if〜else if〜 else〜else
xが成立した場合、処理2が実行される。
yが成立した場合、処理3が実行される。
yも成立しない場合、処理4が実行される。

  処理1;

  if(x)
  {
    /* xが成立する場合、ここが実行される。*/
    処理2;
  }
  else if(y)
  {
    /* xが成立しない。かつyが成立する場合、ここが実行される。*/
    処理3;
  }
  else
  {
    /* xが成立しない。かつyが成立しない場合 */
    /* 上記以外の場合、ここが実行される。*/
    処理4;
  }

  処理5;

以下はテストの点数を受け取り評価A〜Eを返すプログラムの例である。
実際に記述し実行してみよ。

#+NAME: evalTest.c
#+BEGIN_SRC C
#include <stdio.h>

char evalTest(int x)
{
  if(75 <= x)
  {
    return 'A';
  }
  else if(50 <= x)
  {
    return 'B';
  }
  else if(25 <= x)
  {
    return 'C';
  }
  else
  {
    return 'D';
  }
}

int main(void)
{
  int x = 100;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 74;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 49;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 24;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  return 0;
}
#+END_SRC

#+RESULT: evelTest.c
$ ./a.out
evalTest(100) = A
evalTest(74) = B
evalTest(49) = C
evalTest(24) = D

** if〜else if
xが成立する場合、処理2が実行される。
yが成立する場合、処理3が実行される。

  処理1;

  if(x)
  {
    /* xが成立する場合、ここが実行される。*/
    処理2;
  }
  else if(y)
  {
    /* xが成立しない。かつyが成立する場合、ここが実行される。*/
    処理3;
  }

  処理4;

以下はテストの点数を受け取り評価A〜Eを返すプログラムの例である。
実際に記述し実行してみよ。

#+NAME: evalTest01.c
#+BEGIN_SRC C
include <stdio.h>

char evalTest(int x)
{
  if(75 <= x)
  {
    return 'A';
  }
  else if(50 <= x)
  {
    return 'B';
  }
  else if(25 <= x)
  {
    return 'C';
  }

  return 'D';
}

int main(void)
{
  int x = 100;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 74;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 49;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 24;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  return 0;
}
#+END_SRC

#+RESULT: evalTest01.c
$ gcc -Wall evalTest01.c
$ ./a.out
evalTest(100) = A
evalTest(74) = B
evalTest(49) = C
evalTest(24) = D

*** 問題
1. 以下のような入園料を計算するプログラムを作成せよ。(nyuennryou.c)

   65歳以上 : 無料
   18歳以上 : 1800
   18歳未満 : 1200

2. 以下のように性別と年齢で食べ放題料金を決めるプログラムを作成せよ。（tabehoudai.c)

   男性, 6歳以上 : 1000
   女性, 6歳以上 :  800
   男性, 6歳未満 :  200
   女性, 6歳未満 :  200

3. 小文字(a〜z)を大文字(A-Z)に変換するプログラムを作成せよ。

** switch

   switch(x)
   {
     case 定数1:
     　処理1;
       処理1-2;
       break;

     case 定数2:
       処理2;
       break;

     default:
       その他処理;
   }

以下は評価A〜Dを数値4〜1に変換するプログラムである。
実際に記述し実行してみよ。

#+NAME: ab2num.c
#+BEGIN_SRC C
#include <stdio.h>

int ab2num(char e)
{
  int num;
  switch(e)
  {
    case 'A':
      num = 4;
      break;

    case 'B':
      num = 3;
      break;

    case 'C':
      num = 2;
      break;

    default:
      num = 1;
  }

  return num;
}

int main(void)
{
  char e = 'A';
  printf("ab2num(%c) = %d\n", e, ab2num(e));

  e = 'B';
  printf("ab2num(%c) = %d\n", e, ab2num(e));

  e = 'C';
  printf("ab2num(%c) = %d\n", e, ab2num(e));

  e = 'D';
  printf("ab2num(%c) = %d\n", e, ab2num(e));

  return 0;
}
#+END_SRC

#+RESULT: ab2num.c
$ gcc -Wall ab2num.c
$ ./a.out
ab2num(A) = 4
ab2num(B) = 3
ab2num(C) = 2
ab2num(D) = 1

switch文はbreakを記述しない場合、上から下に処理が行われていきます。

以下は評価A〜Dから合否を判定するプログラムである。
実際に記述し実行してみよ。

#+NAME: isOk.c
#+BEGIN_SRC C
#include <stdio.h>

int isOk(char e)
{
  int isOk;
  switch(e)
  {
    case 'A':
    case 'B':
      isOk = 1;
      break;

    case 'C':
    default:
      isOk = 0;
  }

  return isOk;
}

int main(void)
{
  char e = 'A';
  printf("isOk(%c) = %d\n", e, isOk(e));

  e = 'B';
  printf("isOk(%c) = %d\n", e, isOk(e));

  e = 'C';
  printf("isOk(%c) = %d\n", e, isOk(e));

  e = 'D';
  printf("isOk(%c) = %d\n", e, isOk(e));

  return 0;
}
#+END_SRC

#+RESULT: isOk.c
$ gcc -Wall isOk.c
makoto@insp-7380:~/gitHub/Cprac$ ./a.out
isOk(A) = 1
isOk(B) = 1
isOk(C) = 0
isOk(D) = 0

*** 問題
1. isOk.cをif,else if, elseを使用し書き直してみなさい。

** 仕様

「6.8.4 Selection statements」

** 関数型スタイルと再帰
変数への代入を行わないプログラミングに関数型プログラミンがあります。
C言語は関数型のプログラミング言語ではありませんが、関数型プログラミングのスタイルでコードを記述することはできます。
ただし、関数型プログラミング言語の様に関数が第1級オブジェクトではないため、制限があります。
関数型の数学的な記述に近いかたちでコードを記述でき、1つの利点と言われています。

C言語では関数呼び出し時にスタックを使用します。そのため、再帰が深くなりスタックが枯渇するとプログラムが異常終了します。
関数型言語でもスタック同じことは起きますが、末尾再帰の形で記述した再帰処理がgotoになる処理系もありスタックを消費しないコードになります。

以下は再帰を用いて階乗を計算するプログラムとなります。

 fact_rec(0) = 1                  (n == 0)
 fact_rec(n) = n * fact_rec(n-1)  (n != 0)

実際に記述し実行してみよ。

#+NAME: fact_rec.c
#+BEGIN_SRC C
#include <stdio.h>

int fact_rec(const int x)
{
  if(0 == x)
  {
    return 1;
  }
  else
  {
    return x * fact_rec(x - 1);
  }
}

int main(void)
{
  int x = 5;
  printf("fact(%d) = %d\n", x, fact_rec(x));

  return 0;
}
#+END_SRC

#+RESULT: fact_rec.c
$ gcc -Wall fact_rec.c
$ ./a.out
fact(5) = 120

** 問題
1. 消費税を計算する関数 int calcTaxを作成せよ。(calcTax.c)
   税率は,軽減税率対象 8%, その他は10%とせよ。
   小数点の扱いは好きにしてよいものとする。

2. 水量を管理するユーザーからの依頼(適当なでっち上げストーリーです。)

   1. ユ:管理しているタンクの水量が一定量に達した場合に警告を出してほしい。
	 
         ユーザーへの要望に応えるために、警告を発するかどうかの判定関数を
	 用意するこになった。実装してみよ。

   2. ユ:実は、タンクの水量は入と排出の量が常に変動しており、現在だと、警告値付近で警告が頻繁に
　　　　　出たり止まったりする。一度警告状態となったら、ある程度水量が下がった後に警告を解除する様にしてほしい。

        実装してみよ。

3. 0からnまでの整数の和を求める関数を再帰呼び出しを使い実装せよ。
   具体的にすると

   sum(10) = 10 + sum(9)
                  9 + sum(8)
                      8 + sum(7)
      :

   実装に詰まる場合は、fact_recを参考にせよ。(sum_rec.c)

4. FizzBuzz問題
   1. FizzBuzz問題を解くにあたり、ある整数について処理を行う関数を用意することにした。
      void printFizzBuzz(int)のを実装せよ。

      void printFizzBuzz(int)の仕様
        intの値     : 出力する文字列
        3の倍数の場合 : Fizz
        5の倍数の場合 : Buzz
       15の倍数お場合 : FizzBuzz
        それ以外の場合 : 数値そのまま

   2. main関数を以下に置き換えてプログラムを実行してみよ。(fizzBuzzMain.c)

#+begin_src C
int main(int argc, char *argv[])
{
  int num = atoi(argv[1]);
  printFizzBuzz(num);

  return 0;
}
#+end_src

#+result
$ gcc -Wall fizzBuzzMain.c 
$ seq 30 | while read x; do ./a.out $x; echo -n " "; done
1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz 

* 繰り返し
** while

  while(継続条件)
  {
    /* 継続条件成立時 */

    /* 継続条件更新 */
  }

以下は0からnまでの整数の和を求めるプログラムである。
実際に記述し実行してみよ。

#+name : sumWhile.c
#+begin_src C
#include <stdio.h>

int sumWhile(int n)
{ 
  int sum = 0;
  int i = 0;
  while(i <= n)
  {
    sum += i;
    i++;
  }
  
  return sum;
}

int main(void)
{ 
  printf("%d\n", sumWhile(10));

  return 0;
} 
#+end_src

#+result
$ gcc -Wall sumWhile.c 
$ ./a.out 
55

** for

  for(初期化; 継続条件; 継続条件更新)
  {
  }

以下は0からnまでの整数の和を求めるプログラムである。
実際に記述し実行してみよ。

#+name : sumFor.c
#+begin_src C
#include <stdio.h>

int sumFor(int n)
{ 
  int sum = 0;
  int i;
  for(i = 0; i <= n; i++)
  { 
    sum += i;
  } 
  
  return sum;
}

int main(void)
{ 
  printf("%d\n", sumFor(10));

  return 0;
} 
#+end_src

#+result
$ gcc -Wall sumFor.c 
$ ./a.out 
55

** 仕様
「6.8.5 Iteration statements」

** 問題
*** TODO 掛け算九九を出力するプログラムを作成せよ。

**** シンプルな表

まずは、以下のような出力を目指してみよ。

#+begin_example
1  2  3  4  5  6  7  8  9
2  4  6  8 10 12 14 16 18
3  6  9 12 15 18 21 24 27
4  8 12 16 20 24 28 32 36
5 10 15 20 25 30 35 40 45
6 12 18 24 30 36 42 48 54
7 14 21 28 35 42 49 56 63
8 16 24 32 40 48 56 64 72
9 18 27 36 45 54 63 72 81
#+end_example

#+begin_comment
問題の解答例と記述箇所を離したい。
#+end_comment

#+name: simple-kuku
#+begin_src C :results output :cache yes :tangle simple-kuku.c
  #include <stdio.h>

  int main(void)
  {
    for(int i = 1; i < 10; i++) {
      for(int j = 1; j < 10; j++) {
        printf("%3d", i * j);
      }
      putchar('\n');
    }

    return 0;
  }
#+end_src

#+RESULTS[0f01cb8e64f3ce26e0d55f95e0a2d24e71868a49]: simple-kuku
: 1  2  3  4  5  6  7  8  9
: 2  4  6  8 10 12 14 16 18
: 3  6  9 12 15 18 21 24 27
: 4  8 12 16 20 24 28 32 36
: 5 10 15 20 25 30 35 40 45
: 6 12 18 24 30 36 42 48 54
: 7 14 21 28 35 42 49 56 63
: 8 16 24 32 40 48 56 64 72
: 9 18 27 36 45 54 63 72 81

**** ヘッダ情報を装飾の追加

以下のように行と列のヘッダを追加し、装飾を施してみよ。

#+begin_example
x |  1  2  3  4  5  6  7  8  9
--+---------------------------
1 |  1  2  3  4  5  6  7  8  9
2 |  2  4  6  8 10 12 14 16 18
3 |  3  6  9 12 15 18 21 24 27
4 |  4  8 12 16 20 24 28 32 36
5 |  5 10 15 20 25 30 35 40 45
6 |  6 12 18 24 30 36 42 48 54
7 |  7 14 21 28 35 42 49 56 63
8 |  8 16 24 32 40 48 56 64 72
9 |  9 18 27 36 45 54 63 72 81
#+end_example

#+name: deco-kuku
#+begin_src C :results output :cache yes :tangle deco-kuku.c
  #include <stdio.h>

  void printTopHeader(int num)
  {
    printf("x |");
    for(int i = 1; i <= num; i++) {
      printf("%3d", i);
    }
    putchar('\n');
  }

  int main(void)
  {
    printTopHeader(9);
    puts("--+---------------------------");
    for(int i = 1; i < 10; i++) {
      printf("%d |", i);
      for(int j = 1; j < 10; j++) {
        printf("%3d", i * j);
      }
      putchar('\n');
    }

    return 0;
  }
#+end_src

#+RESULTS[f766b3d35d66c71873783fe39b99cd801a508c88]: deco-kuku
#+begin_example
x |  1  2  3  4  5  6  7  8  9
--+---------------------------
1 |  1  2  3  4  5  6  7  8  9
2 |  2  4  6  8 10 12 14 16 18
3 |  3  6  9 12 15 18 21 24 27
4 |  4  8 12 16 20 24 28 32 36
5 |  5 10 15 20 25 30 35 40 45
6 |  6 12 18 24 30 36 42 48 54
7 |  7 14 21 28 35 42 49 56 63
8 |  8 16 24 32 40 48 56 64 72
9 |  9 18 27 36 45 54 63 72 81
#+end_example

*** 図形の描画

図形を描画するプログラムを作成せよ。
なお、問題を解くにあたり必要な関数は自由に実装せよ。

元ネタ：「明解 C言語」

     1. 横棒 3指定
        #+begin_example
        ***
        #+end_example
     2. 四角形 4,2指定
        #+begin_example
        *****
        *****
        #+end_example
     3. 直角三角形

        1. 4指定
           #+begin_example
           *
	       **
	       ***
           ****
           #+end_example

        2. 4指定
           #+begin_example
           *
           **
           ***
           ****
           #+end_example
     4. 二等辺三角形 3指定
        #+begin_example
          *
         ***
        *****
        #+end_example
     5. 平行四辺形 5,3指定
        #+begin_example
        *****
         *****
          *****
        #+end_example

*** 福利計算
**** 福利

元金,年利,年数を指定して各年毎の元金を表示させてみよ。
元金100万円、年利3%を想定し、得た利益はそのまま次年の元金にする。
10年後にいくらになるかを計算せよ。

| moto | rieki |
|  100 |   103 |
|  203 |       |

#+name: hukuri
#+begin_src C :cache yes :tangle hukuri.c
  #include <stdio.h>

  int main(void) {

    double gankin = 100;
    double nenri = 0.03;
    int nen = 10;

    for(int i = 0; i < nen; i++) {
      double rieki = gankin * nenri;
      printf("%d, %f, %f\n", i + 1, gankin, rieki);

      gankin += rieki;
    }

    return 0;
  }
#+end_src

#+RESULTS[5b16a43710b384b6a21d4a65180e1b2459667687]: hukuri
|  1 |      100.0 |      3.0 |
|  2 |      103.0 |     3.09 |
|  3 |     106.09 |   3.1827 |
|  4 |   109.2727 | 3.278181 |
|  5 | 112.550881 | 3.376526 |
|  6 | 115.927407 | 3.477822 |
|  7 |  119.40523 | 3.582157 |
|  8 | 122.987387 | 3.689622 |
|  9 | 126.677008 |  3.80031 |
| 10 | 130.477318 |  3.91432 |

**** 毎年, 福利

上記の想定を少し変更し、毎年元金に100万円を加えた場合を考えてみよ。

#+name: hukuri2
#+begin_src C :cache yes :tangle hukuri2.c
  #include <stdio.h>

  int main(void) {

    double gankin = 100;
    double mai = 100;
    double nenri = 0.03;
    int nen = 10;

    for(int i = 0; i < nen; i++) {
      double rieki = gankin * nenri;
      printf("%d, %f, %f\n", i + 1, gankin, rieki);

      gankin += mai + rieki;
    }

    return 0;
  }
#+end_src

#+RESULTS[d82b297e8b366e7c68ca6b864ae74f52c672c2bf]: hukuri2
|  1 |       100.0 |       3.0 |
|  2 |       203.0 |      6.09 |
|  3 |      309.09 |    9.2727 |
|  4 |    418.3627 | 12.550881 |
|  5 |  530.913581 | 15.927407 |
|  6 |  646.840988 |  19.40523 |
|  7 |  766.246218 | 22.987387 |
|  8 |  889.233605 | 26.677008 |
|  9 | 1015.910613 | 30.477318 |
| 10 | 1146.387931 | 34.391638 |

**** 手軽に複数にシミュレーションが行えるようにしてみよ。

例
- 関数化
- コマンドとして実行できるようにする。

**** 出力結果を他のプログラムで利用する例を考えてみよ。

例

- 元金を変更したパターンの結果をグラフに表示させてみる。

*** 入力バイトカウントアップ

  5. 標準入力から入力されたバイト数をカウントし結果を出力するプログラムを作成せよ。
     作成したプログラムの結果とwc -c の結果を比較してみよ。

*** 入力データ16進ダンプ

  6. 標準入力から入力された文字を16進数で出力するプログラムを作成せよ。
     作成したプログラムの結果とodやhexdumpの結果を比較してみよ。

*** 配列要素の最大値

  7. 整数の配列から最大値の情報を返す関数を実装し、main関数から呼び出してみなさい。

*** break, continueの使用例

break, continue の使用例を考えてみなさい。

*** STARTED 2重ループからの脱出

**** 9x9の2次元配列に掛け算九九を保存し画面に表を出力させなさい

#+begin_src C :results output :tangle kuku2d.c :cache yes
  #include <stdio.h>

  int main(void) {
    int kuku[9][9];

    for(int gyou = 1; gyou <= 9; gyou++) {
      for(int retsu = 1; retsu <= 9; retsu++) {
        kuku[gyou-1][retsu-1] = gyou * retsu;
      }
    }

    for(int gyou = 1; gyou <= 9; gyou++) {
      for(int retsu = 1; retsu <= 9; retsu++) {
        printf("%3d", kuku[gyou-1][retsu-1]);
      }
      putchar('\n');
    }

    return 0;
  }
#+end_src

#+RESULTS[95bb84953113f4f1249936a3eabcc34defe07a51]:
: 1  2  3  4  5  6  7  8  9
: 2  4  6  8 10 12 14 16 18
: 3  6  9 12 15 18 21 24 27
: 4  8 12 16 20 24 28 32 36
: 5 10 15 20 25 30 35 40 45
: 6 12 18 24 30 36 42 48 54
: 7 14 21 28 35 42 49 56 63
: 8 16 24 32 40 48 56 64 72
: 9 18 27 36 45 54 63 72 81



1. breekの利用
2. gotoの利用

*** 偶数列の和

偶数の数列があるとする。偶数nからmまでの和を求めよ。
ただし、n<mとする。

*** 奇数列の和

奇数の数列があるとする。奇数nからmまでの和を求めよ。
ただし、n<mとする。

*** 3の倍数の数列の和

3の倍数の数列があるとする。nからmまでの和を求めよ。
ただし、n<mとする。

*** 要素毎の和

以下のようなデータが提供された。
#+begin_src C
  int data[] = { 1, 2, 3, 4, 5, 6};
#+end_src
データの提供元からは、利用の際は、以下のように2要素ごとの和を計算し利用するように言われた。

#+begin_src C
  int trans[] = { 1 + 2, 3 + 4, 5 + 6 };
#+end_src

データの変換をプログラムにて行ってみよ。提供データの要素数は偶数個であるとする。

* ポインタ
** 説明1
言葉について考えてみます。ポインタ(pointer)とはポイントするものです。

例えば、プレゼンテーションでは、説明者がプロジェクターで映し出された資料を指す(ポイントする)ために
レーザーポインタを使用したりします。つまり、(レーザー)ポインタは資料を指すものです。

C言語におけるポインタが何を指しているかというと、メモリアドレスを指しています。

これまで、使用してきた変数は基本的に各型に対応する値を保持していました。
変数はメモリ上に保存されていますが、特にメモリアドレスを意識せずに使用してきました。

#+begin_comment
識別し、変数、アドレスがわかる図を挿入したい。
#+end_comment


  int x = 10;   /* int型の変数xは10という値を保持している。変数にアクセスする際は、識別子xを指定する。 */
  char c = 'A'; /* char型の変数cは'A'という値を保持している。変数にアクセスする際は、識別子cを指定する。*/

ポインタを使用することによって、これまで意識してこなかったメモリアドレスについて意識する必要が出てきますが、
代わりにプログラマがメモリアドレスを意識したプログラムを記述することができます。

  int *px;      /* int型の値を指すメモリアドレスを保持する変数px */
  px = &x;      /* 変数xのアドレスを変数pxに保持する。         */
  *px;          /* pxが変数xのアドレスを指しているので、*pxの値は、xの値となる。*/

  char *pc = &c; /* char型の値を指すメモリアドレスを保持する変数pcに変数cのアドレスを保持する。*/
  *pc;           /* pcが変数cのアドレスを指しているので、*cの値はcの値となる。*/

&はリファレンス(reference)、*はリファレンスの逆、デリファレンス(dereference)といいます。

ポインタは、メモリを直接扱うということからも低級(低レベル)の機能といえます。
そのため、ポインタの有効性を理解するには、C言語だけではなく低レベルの機能についての理解が必要になります。

ここでは、低レベルの機能について説明は、行わずポインタの使用例上げていきたいと思います。

** 説明2
ポインタ型の変数とは、アドレスを保存する変数です。現実の住所と比較してコメントを入れてみます。

/* ハインツ川崎 : 10階建 */
int x = 10; /* 住所の情報は見えない。(意識しなくてよい。) */

/* ハインツ川崎の住所を得るには &x とする。*/
/* &x 神奈川県 川崎市1番地 である。*/
   &x

/* ハインツ川崎 住所保存用の変数を用意する。*/
int *px;

/* 変数 px に ハインツ川崎の住所(&x : 神奈川県 川崎市1番地)を代入する。*/
int *px = &x;

/* 住所(神奈川県 川崎市1番地)の建物を 20階建にする。*/
*px = 20;

** ポインタの使用例(理解に向けて)
以下のプログラムはポインタの理解を助けることを目的としたプログラムです。
実際に記述し実行し結果を確認してみて下さい。

#+NAME: pointer01.c
#+BEGIN_SRC C
#include <stdio.h>

int main(void)
{
  int x = 10;
  int *px = &x;

  printf("xの値:%d, xのメモリアドレス:%p\n", x, &x);
  printf("pxの値:%p, pxのメモリアドレス: %p, pxが指すメモリアドレスに保持している値:%d\n",px, &px, *px);

  return 0;
}
#+END_SRC

#+RESULT: pointer01.c
$ gcc -Wall pointer01.c
$ ./a.out
xの値:10, xのメモリアドレス:0x7ffe40e0ce9c
pxの値:0x7ffe40e0ce9c, pxのメモリアドレス: 0x7ffe40e0cea0, pxが指すメモリアドレスの値:10

上記の結果を整理してみます。
                                 
名前, メモリに保持する値,  　　メモリアドレス(これまで意識してこなかった部分)
  x,              10,   0x7ffe40e0ce9c
 px,  0x7ffe40e0ce9c,   0x7ffe40e0cea0

xの値を取得するには、識別子xでアクセスし、メモリの保持する値10を得る。(これまで)
pxの値を取得するには、識別子pxでアクセスし、メモリの保持する値0x7ffe40e0ce9cを得る。(ポインタ)

識別子(xやpx)で値にアクセスするのはこれまでと同じです。
これはでは、整数値や実数値、文字を取得していましたが、これにメモリアドレスが加わります。

  リファレンス  &x =   0x7ffe40e0ce9c  = px
               x = *(0x7ffe40e0ce9c) = *px デリファレンス

** ポインタの理解(同一アドレスの更新)

#+NAME: pointer02.c
#+BEGIN_SRC C
#include <stdio.h>

int main(void)
{
  int x = 10;
  int *px = &x;

  printf("x = %d, *px = %d\n", x, *px);

  x = 11;
  printf("x = %d, *px = %d\n", x, *px);

  *px = 12;
  printf("x = %d, *px = %d\n", x, *px);

  return 0;
}
#+END_SRC

#+RESULT: pointer02.c
$ gcc -Wall pointer02.c
$ ./a.out
x = 10, *px = 10
x = 11, *px = 11
x = 12, *px = 12

pxがxのアドレスを保持しているので、xと*pxで同じ結果となっています。

** 呼び出し先関数で引数の値を更新する

#+name: pointer03.c
#+begin_src C
#include <stdio.h>

void funcNG(unsigned char x)
{
  x = 0xff;
}

void funcOK(unsigned char *x)
{
  *x = 0xff;
}

int main(void)
{
  unsigned char x = 0xaa;

  funcNG(x);
  printf("x = %x\n", x);

  funcOK(&x);
  printf("x = %x\n", x);

  return 0;
}
#+end_src

#+result: pointer03.c
$ gcc -Wall -g pointer03.c 
$ ./a.out 
x = aa
x = ff

funcNG内でx=0xffを実行していますが、xの結果は変化せずに0xaaとなっています。
関数の呼び出し時には呼び出し元の引数が保持する値のコピーが渡されます。そのため、
コピーされた値を呼び出し先で変更しても、呼び出し元には影響しません。

不便に思うかも知れませんが、呼び出し元の変数に影響を与えないことは利点です。
ただ、変更したい場合もあるのでその様な場合は呼び出し元のメモリアドレス情報を
渡すわけです。

** scanfの使用例

#+name : sampel_scanf01.c
#+begin_src C
#include <stdio.h>

int main(void)
{
  printf("整数値を入力して下さい : ");

  int in;
  scanf("%d", &in);

  printf("入力された整数値は、%dでした。\n", in);

  return 0;
}
#+end_src

#+name : sample_scanf02.c
#+begin_src C
#include <stdio.h>

int main(void)
{
  printf("整数値を入力して下さい : ");

  int in;
  int *pin = &in;

  scanf("%d", pin);

  printf("入力された整数値は、%dでした。\n", in);
  printf("入力された整数値は、%dでした。\n", *pin);

  return 0;
}
#+end_src

*** 問題
1. pointer03.cを修正し各種変数のメモリアドレス情報を出力させてみよ。

2. char型要素数4の配列ca[4]を用意し、各値のアドレスと値を表示させてみよ。(charArray.c)
   表示にはcaのアドレスを含めよ。また、文字型のポインタを用意し、配列の
   添字との関係性を見てみよ。

3. 整数の割り算の商と余りを返す関数(shoAmari.c)
4. 数値配列に変更加える。(updArray.c)
5. 数値配列の値を変更した結果を別の配列に入れる。(updArray.c)
7. 文字列を走査し指定した文字の位置を返す関数
8. 配列から指定した条件に一致したものと、一致しなかったものを返す
9. scanfを利用してみる。簡易的なcsv入力(pracScanf.c)
10. 数値配列に対して、qsortを利用してみよ。(pracQsort.c)
11. 和の関数シグマを定義せよ。(sum.c)
12. 積の関数パイを定義せよ。(sum.c)

* 構造体,共用体
別の種類のデータを一つにまとめたもの

** 宣言
struct タグ名
{
  型名 メンバ名;
  :
};

** 使用時

 struct タグ名 変数名;

 変数名.メンバ名

** 仕様

「6.7.2.1 Structure and union specifiers」

** 問題 
   1. 2次元デカルト座標系を表現するために構造体を利用してみよ。(struct.c, point.h, pint1.c)
   2. 単方向リストを実装してみよ。(sampleList.c)
   3. 学生データ
   4. 統計データ


* 修飾
* デバッガ(GDB)
* 総合
** 積を計算するプログラムを和で実装しなさい。

#+begin_src C
  int mul(int x, int y) {
    int sum = 0;
    for(int i = 0; i < y; i++) {
      sum += x;
    }

    return sum;
  }

  int main(void) {
    int x = 3;
    int y = 7;
    printf("%d * %d = %d\n", x, y, mul(x, y));

    return 0;
  }
#+end_src

#+RESULTS:
: 3 * 7 = 21

実装後以下を考えてみなさい。

- xまたはyが0の場合、積の結果は0となる。この場合は、繰り返しによる和の実行は不要である。
  作成したプログラムにこの考えが入っていない場合、実装してみよ。
- xが1の場合、積の結果はyである。また、yが1の場合、積の結果はxである。
  作成したプログラムにこの考えが入っていない場合、実装してみよ。

** 商を計算するプログラムを差で実装しなさい。
** 余り(剰余)を計算するプログラムを差で実装しなさい。
** 商と余りを得るプログラムを差で実装しなさい。
** ポインタ「const * char * const pChar」についてconstがどのような効果を持っているか考えてみなさい。
** IPv4のブロードキャストアドレス
   IPv4のIPアドレスとサブネットマスクを引数として、ブロードキャストアドレス
   を算出するプログラムを作成せよ。実装に詰まる場合は以下の流れを参考にせよ。

   1. 1バイト(8ビット)データを2進数で出力する関数を作成せよ。

        void print_bit(unsigned char x)

   2. ipv4アドレスを2進数で出力する関数を作成せよ。

        void print_ipv4_addr(unsigned char *x)

        xは4バイトの配列とし、x[0]が第1オクテット,...x[3]が第4オクテットに対応するものとする。
        また、各オクテット毎にはドット(.)を出力し区切りを明確にせよ。

   3. unsigned char 型、要素4の配列で、IPv4アドレスと、サブネットマスクを表現することにし、
      これにビット演算を適用することでブロードキャストアドレスを算出せよ。

      トライ&エラー時の結果確認では、print_ipv4_addrが役に立つだろう。

   4. IPv4アドレス,サブネットマスクは4バイト(32ビット)の情報なので、ungiend int 型に収まるはずである。
      また、int型として扱うことで配列の各要素に対して行っていた演算を1度に実行できるはずである。
      この考えを元に、unsigned char 型,要素数4の配列をunsigned int型の配列として扱いブロードキャストアドレスを
      算出してみよ。

      ヒント : キャストを利用せよ。

   5. この問題の場合、unsigned char 型 要素数4 と unsigned int型のデータは同じデータなので、
      同一のものとして扱えるよいだろう。この目的のために共用体を利用してみよ。

   6. 練習としてプログラムに思いつく修正を加えてみよ。
      1. ネットワークアドレスを算出する関数を作成せよ。
      2. Ipv4アドレスの設定を4つの引数 func(oct1, oct2, oct3, oct4)の様な形式で設定する関数を
	 作成せよ。
      3. IPv4アドレスの設定を 192.168.10.3の様な形式で指定できるようにせよ。
      4. ブロードキャストアドレスを192.168.10.3/25の様な形式で指定できるようにせよ。

** 関数単体試験
*** モジュールの分離
1. 「条件分岐」問題2.2を解いてみよ。
    ファイル名はsuiryou.cとする。

2. suiryou_testディレクトリを作成しsuiryou.cをそこに移動せよ。
3. suiryou.cについて、警告用関数の別モジュールに分離せよ。また、ヘッダファイルを用意せよ。
4. これまで通り動作することを確認せよ。

*** Makefileの作成
1. 以下のMakefileを用意せよ。

$ cat Makefile
all: suiryou

suiryou : main.c suiryou.c suiryou.h
	gcc -Wall main.c suiryou.c -o suiryou

clean :
	rm -rf a.out *.o suiryou

2. 1のMakefileはsuiryou実行ファイルを作成するための依存関係が一つにまとまっている。
   そのため、main.c, suiryou.c, suiryou.hのどれが変更されてもmain.c, suiryou.cの
   コンパイルとリンクが行われる。
   依存関係の記述を修正してみよ。

*** CppUTest

** #includeって何してるの?
** ライブラリを作成する
** 簡易cat
間的なcatコマンドをシステムコールを利用して作成せよ。
open, read, writeを使用せよ。

** CDプレーヤーのモデル
・再生, 停止, トレイオープン, トレイクローズ
・CDが入っている, CDが入っていない。

** pingを変更してみる
 - [[https://www.gnu.org/software/inetutils/manual/html_node/index.html][GNU Inetutils]]

** netstatの仕組みを調べる
 - [[https://net-tools.sourceforge.io/][netstat]]

** netcat
 - [[https://ja.wikipedia.org/wiki/Netcat][netcat]]

** echoクライアント, echoサーバ
** 有理数計算

参考 : [[https://sicp.iijlab.net/fulltext/x211.html][2.1.1 例: 有理数の算術演算]]

** 配列に対する操作

- 変換, map, functor
- 条件が成立したものを集める。
  - 条件は2パターン用意する。
    - 偶数
    - 3の倍数
- 条件が成立しなかったものを集める。
- 条件が、成立したものと成立しなかったものを別に集める。

:アイデア:
関数合成を使用する例も紹介したい。
:END:

*** map関数

#+begin_comment
これは関数ポインタの例にしたほうが良いかもしれないな。
#+end_comment

関数型の言語にはmapが用意されているC言語にてmapの機能を模倣してみよ。
以下は、emacs-lispでmapに相当するmapcarを使用した例である。

#+name: mapの例
#+begin_src elisp
  (defun square (x) (* x x))
  (mapcar #'square '(1 2 3 4 5))
#+end_src

#+RESULTS: mapの例
| 1 | 4 | 9 | 16 | 25 |

まずは、mapを意識せずに適当に同じような処理を実装してみる。
C言語ということで配列を利用して実装してみる。

#+begin_src C :results output
  #include <stdio.h>

  int square(int x) {
    return x * x;
  }

  int main(void) {
    int a[] = { 1, 2, 3, 4, 5 };

    for(int i = 0; i < sizeof(a)/sizeof(int); i++) {
      a[i] = square(a[i]);
    }

    for(int i = 0; i < sizeof(a)/sizeof(int); i++) {
      printf("%d ", a[i]);
    }

    return 0;
  }
#+end_src

#+RESULTS:
: 1 4 9 16 25 

元の配列を変更するのは気持ちが悪いので、保存先の配列を用意することにする。

#+begin_src C
  #include <stdio.h>

  int square(int x) {
    return x * x;
  }

  int main(void) {
    int a[] = { 1, 2, 3, 4, 5 };
    int ra[sizeof(a)/sizeof(int)];

    for(int i = 0; i < sizeof(a)/sizeof(int); i++) {
      ra[i] = square(a[i]);
    }

    for(int i = 0; i < sizeof(a)/sizeof(int); i++) {
      printf("%d ", ra[i]);
    }

    return 0;
  }
#+end_src

#+RESULTS:
: 1 4 9 16 25

map部分を関数化する。

#+begin_src C
  #include <stdio.h>

  int square(int x) {
    return x * x;

  }

  void map(int (*func)(int), int a[], size_t num, int ra[]) {
    for(int i = 0; i < num; i++) {
      ra[i] = func(a[i]);
    }
  }

  int main(void) {
    int a[] = { 1, 2, 3, 4, 5 };
    int ra[sizeof(a)/sizeof(int)];

    map(square, a, sizeof(a)/sizeof(int), ra);

    for(int i = 0; i < sizeof(a)/sizeof(int); i++) {
      printf("%d ", ra[i]);
    }

    return 0;
  }
#+end_src

#+RESULTS:
: 1 4 9 16 25

mapのfuncはint型を引数にとる関数となっているが、ここで任意の型をとることはできるだろうか。
考えてみよ。

2次元のデカルト座標系の点を表す構造体を用意し、原点からの距離を求めてみる。

#+begin_comment
意外と面倒だな。
#+end_comment

*** 問題
1から10までの整数値を保存した配列がある。

#+name: 入力配列
#+begin_src C
  int array[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
#+end_src

この配列の要素全てを2乗する処理を考えよ。その際に、以下を考えよ。

- 元の配列の変更を許可する場合
- 元の配列の変更を許可しない場合
  - 処理結果の配列を引数として受け取る場合
  - 処理結果の配列を返す場合

*** 元の配列の変更を許可する場合の解答例

#+begin_src C :results raw :noweb yes :cache yes :include <stdio.h>
  int main(void) {

    <<入力配列>>

    /* 2乗の計算結果で更新する。*/
    for(int i = 0; i < sizeof(array)/sizeof(int); i++) {
      array[i] = array[i] * array[i];
    }

    /* 計算結果を確認する。*/
    for(int i = 0; i < sizeof(array)/sizeof(int); i++) {
      printf("array[%d] = %3d\n", i, array[i]);
    }

    return 0;
  }
#+end_src

#+RESULTS[1131e0893b61ab3335b67d767404ba6dfbda6115]:
array[0] =   1
array[1] =   4
array[2] =   9
array[3] =  16
array[4] =  25
array[5] =  36
array[6] =  49
array[7] =  64
array[8] =  81
array[9] = 100

上記のプログラムを変更して遊んでみる。

  1. 2上を計算する部分を関数化してみよ。
  2. 計算結果を確認する部分を関数化してみよ。
     1. まずは、思いつくままに関数化してみよ。
     2. 汎用性を上げるにはどうすればよいだろうか。

**** 2乗を計算する部分の関数化

#+name: square関数実装
#+begin_src C
  int square(int x) {
    return x * x;
  }
#+end_src

#+begin_src C :results raw :noweb yes :cache yes :include <stdio.h>
  <<square関数実装>>
  
  int main(void) {

    <<入力配列>>

    /* 2乗の計算結果で更新する。*/
    for(int i = 0; i < sizeof(array)/sizeof(int); i++) {
      array[i] = square(array[i]);
    }

    /* 計算結果を確認する。*/
    for(int i = 0; i < sizeof(array)/sizeof(int); i++) {
      printf("array[%d] = %3d\n", i, array[i]);
    }

    return 0;
  }
#+end_src

#+RESULTS[6dc8949151da5df8fe1207404fe1297c5964c03e]:
array[0] =   1
array[1] =   4
array[2] =   9
array[3] =  16
array[4] =  25
array[5] =  36
array[6] =  49
array[7] =  64
array[8] =  81
array[9] = 100

**** 結果確認部分の関数化

まずは、思いつくままに書いてみる。

#+name: print_results
#+begin_src C
  #include <stdio.h>

  void print_results(int array[], size_t size) {
    for(int i = 0; i < size; i++) {
      printf("array[%d] = %3d\n", i, array[i]);
    }
  }
#+end_src

#+RESULTS: print_results

#+begin_src C :results raw :noweb yes :cache yes :include <stdio.h>
  
  <<square関数実装>>
  <<print_results>>

  int main(void) {

    <<入力配列>>

    /* 2乗の計算結果で更新する。*/
    for(int i = 0; i < sizeof(array)/sizeof(int); i++) {
      array[i] = square(array[i]);
    }

    /* 計算結果を確認する。*/
    print_results(array, sizeof(array)/sizeof(int));

    return 0;
  }
#+end_src

#+RESULTS[adcdad4d9dea7048434e035324d746dd98e700fd]:
array[0] =   1
array[1] =   4
array[2] =   9
array[3] =  16
array[4] =  25
array[5] =  36
array[6] =  49
array[7] =  64
array[8] =  81
array[9] = 100

[[print_results]]は、配列の識別子まで、実装側で入れ込んでいる。これを外部から指定可能にする方法は
あるだろうか。より汎用的なことが可能かを考えてみよ。

識別子を文字列として受取り出力を変更する程度しか行えなさそうである。

** 配列とアドレス

#+begin_src C :results output
  #include <stdio.h>

  int main(void) {
    int a2[10][10];

    int count = 0;
    for(int i = 0; i < 10; i ++) {
      for(int j = 0; j < 10; j++) {
        a2[i][j] = count;
        count++;
      }
    }

    /* 先頭から1要素毎にアドレス出力 */
    /* 10行10列 */
    for(int i = 0; i < 10; i ++) {
      for(int j = 0; j < 10; j++) {
        printf("%p : a2[%d][%d] = %3d\n", &a2[i][j], i, j, a2[i][j]);
      }
    }

    /* 1行100列の配列として見た場合 */
    int *ap = (int *)a2;
    for(int i = 0; i < 100; i++) {
      printf("%p : ap[%d] = %3d\n", &ap[i], i, ap[i]);
    }

    #if 0
    /* 5行20列の配列として見た場合 */
    int *ap2 = (int [5])a2;
    for(int i = 0; i < 5; i ++) {
      for(int j = 0; j < 20; j++) {
        /* 修正中 */
        printf("%p : ap2[%d][%d] = %3d\n", &ap2[i][j], i, j, ap2[i][j]);
      }
    }
    #endif
  }
#+end_src

#+RESULTS:
#+begin_example
0x7ffcda285bf0 : a2[0][0] =   0
0x7ffcda285bf4 : a2[0][1] =   1
0x7ffcda285bf8 : a2[0][2] =   2
0x7ffcda285bfc : a2[0][3] =   3
0x7ffcda285c00 : a2[0][4] =   4
0x7ffcda285c04 : a2[0][5] =   5
0x7ffcda285c08 : a2[0][6] =   6
0x7ffcda285c0c : a2[0][7] =   7
0x7ffcda285c10 : a2[0][8] =   8
0x7ffcda285c14 : a2[0][9] =   9
0x7ffcda285c18 : a2[1][0] =  10
0x7ffcda285c1c : a2[1][1] =  11
0x7ffcda285c20 : a2[1][2] =  12
0x7ffcda285c24 : a2[1][3] =  13
0x7ffcda285c28 : a2[1][4] =  14
0x7ffcda285c2c : a2[1][5] =  15
0x7ffcda285c30 : a2[1][6] =  16
0x7ffcda285c34 : a2[1][7] =  17
0x7ffcda285c38 : a2[1][8] =  18
0x7ffcda285c3c : a2[1][9] =  19
0x7ffcda285c40 : a2[2][0] =  20
0x7ffcda285c44 : a2[2][1] =  21
0x7ffcda285c48 : a2[2][2] =  22
0x7ffcda285c4c : a2[2][3] =  23
0x7ffcda285c50 : a2[2][4] =  24
0x7ffcda285c54 : a2[2][5] =  25
0x7ffcda285c58 : a2[2][6] =  26
0x7ffcda285c5c : a2[2][7] =  27
0x7ffcda285c60 : a2[2][8] =  28
0x7ffcda285c64 : a2[2][9] =  29
0x7ffcda285c68 : a2[3][0] =  30
0x7ffcda285c6c : a2[3][1] =  31
0x7ffcda285c70 : a2[3][2] =  32
0x7ffcda285c74 : a2[3][3] =  33
0x7ffcda285c78 : a2[3][4] =  34
0x7ffcda285c7c : a2[3][5] =  35
0x7ffcda285c80 : a2[3][6] =  36
0x7ffcda285c84 : a2[3][7] =  37
0x7ffcda285c88 : a2[3][8] =  38
0x7ffcda285c8c : a2[3][9] =  39
0x7ffcda285c90 : a2[4][0] =  40
0x7ffcda285c94 : a2[4][1] =  41
0x7ffcda285c98 : a2[4][2] =  42
0x7ffcda285c9c : a2[4][3] =  43
0x7ffcda285ca0 : a2[4][4] =  44
0x7ffcda285ca4 : a2[4][5] =  45
0x7ffcda285ca8 : a2[4][6] =  46
0x7ffcda285cac : a2[4][7] =  47
0x7ffcda285cb0 : a2[4][8] =  48
0x7ffcda285cb4 : a2[4][9] =  49
0x7ffcda285cb8 : a2[5][0] =  50
0x7ffcda285cbc : a2[5][1] =  51
0x7ffcda285cc0 : a2[5][2] =  52
0x7ffcda285cc4 : a2[5][3] =  53
0x7ffcda285cc8 : a2[5][4] =  54
0x7ffcda285ccc : a2[5][5] =  55
0x7ffcda285cd0 : a2[5][6] =  56
0x7ffcda285cd4 : a2[5][7] =  57
0x7ffcda285cd8 : a2[5][8] =  58
0x7ffcda285cdc : a2[5][9] =  59
0x7ffcda285ce0 : a2[6][0] =  60
0x7ffcda285ce4 : a2[6][1] =  61
0x7ffcda285ce8 : a2[6][2] =  62
0x7ffcda285cec : a2[6][3] =  63
0x7ffcda285cf0 : a2[6][4] =  64
0x7ffcda285cf4 : a2[6][5] =  65
0x7ffcda285cf8 : a2[6][6] =  66
0x7ffcda285cfc : a2[6][7] =  67
0x7ffcda285d00 : a2[6][8] =  68
0x7ffcda285d04 : a2[6][9] =  69
0x7ffcda285d08 : a2[7][0] =  70
0x7ffcda285d0c : a2[7][1] =  71
0x7ffcda285d10 : a2[7][2] =  72
0x7ffcda285d14 : a2[7][3] =  73
0x7ffcda285d18 : a2[7][4] =  74
0x7ffcda285d1c : a2[7][5] =  75
0x7ffcda285d20 : a2[7][6] =  76
0x7ffcda285d24 : a2[7][7] =  77
0x7ffcda285d28 : a2[7][8] =  78
0x7ffcda285d2c : a2[7][9] =  79
0x7ffcda285d30 : a2[8][0] =  80
0x7ffcda285d34 : a2[8][1] =  81
0x7ffcda285d38 : a2[8][2] =  82
0x7ffcda285d3c : a2[8][3] =  83
0x7ffcda285d40 : a2[8][4] =  84
0x7ffcda285d44 : a2[8][5] =  85
0x7ffcda285d48 : a2[8][6] =  86
0x7ffcda285d4c : a2[8][7] =  87
0x7ffcda285d50 : a2[8][8] =  88
0x7ffcda285d54 : a2[8][9] =  89
0x7ffcda285d58 : a2[9][0] =  90
0x7ffcda285d5c : a2[9][1] =  91
0x7ffcda285d60 : a2[9][2] =  92
0x7ffcda285d64 : a2[9][3] =  93
0x7ffcda285d68 : a2[9][4] =  94
0x7ffcda285d6c : a2[9][5] =  95
0x7ffcda285d70 : a2[9][6] =  96
0x7ffcda285d74 : a2[9][7] =  97
0x7ffcda285d78 : a2[9][8] =  98
0x7ffcda285d7c : a2[9][9] =  99
0x7ffcda285bf0 : ap[0] =   0
0x7ffcda285bf4 : ap[1] =   1
0x7ffcda285bf8 : ap[2] =   2
0x7ffcda285bfc : ap[3] =   3
0x7ffcda285c00 : ap[4] =   4
0x7ffcda285c04 : ap[5] =   5
0x7ffcda285c08 : ap[6] =   6
0x7ffcda285c0c : ap[7] =   7
0x7ffcda285c10 : ap[8] =   8
0x7ffcda285c14 : ap[9] =   9
0x7ffcda285c18 : ap[10] =  10
0x7ffcda285c1c : ap[11] =  11
0x7ffcda285c20 : ap[12] =  12
0x7ffcda285c24 : ap[13] =  13
0x7ffcda285c28 : ap[14] =  14
0x7ffcda285c2c : ap[15] =  15
0x7ffcda285c30 : ap[16] =  16
0x7ffcda285c34 : ap[17] =  17
0x7ffcda285c38 : ap[18] =  18
0x7ffcda285c3c : ap[19] =  19
0x7ffcda285c40 : ap[20] =  20
0x7ffcda285c44 : ap[21] =  21
0x7ffcda285c48 : ap[22] =  22
0x7ffcda285c4c : ap[23] =  23
0x7ffcda285c50 : ap[24] =  24
0x7ffcda285c54 : ap[25] =  25
0x7ffcda285c58 : ap[26] =  26
0x7ffcda285c5c : ap[27] =  27
0x7ffcda285c60 : ap[28] =  28
0x7ffcda285c64 : ap[29] =  29
0x7ffcda285c68 : ap[30] =  30
0x7ffcda285c6c : ap[31] =  31
0x7ffcda285c70 : ap[32] =  32
0x7ffcda285c74 : ap[33] =  33
0x7ffcda285c78 : ap[34] =  34
0x7ffcda285c7c : ap[35] =  35
0x7ffcda285c80 : ap[36] =  36
0x7ffcda285c84 : ap[37] =  37
0x7ffcda285c88 : ap[38] =  38
0x7ffcda285c8c : ap[39] =  39
0x7ffcda285c90 : ap[40] =  40
0x7ffcda285c94 : ap[41] =  41
0x7ffcda285c98 : ap[42] =  42
0x7ffcda285c9c : ap[43] =  43
0x7ffcda285ca0 : ap[44] =  44
0x7ffcda285ca4 : ap[45] =  45
0x7ffcda285ca8 : ap[46] =  46
0x7ffcda285cac : ap[47] =  47
0x7ffcda285cb0 : ap[48] =  48
0x7ffcda285cb4 : ap[49] =  49
0x7ffcda285cb8 : ap[50] =  50
0x7ffcda285cbc : ap[51] =  51
0x7ffcda285cc0 : ap[52] =  52
0x7ffcda285cc4 : ap[53] =  53
0x7ffcda285cc8 : ap[54] =  54
0x7ffcda285ccc : ap[55] =  55
0x7ffcda285cd0 : ap[56] =  56
0x7ffcda285cd4 : ap[57] =  57
0x7ffcda285cd8 : ap[58] =  58
0x7ffcda285cdc : ap[59] =  59
0x7ffcda285ce0 : ap[60] =  60
0x7ffcda285ce4 : ap[61] =  61
0x7ffcda285ce8 : ap[62] =  62
0x7ffcda285cec : ap[63] =  63
0x7ffcda285cf0 : ap[64] =  64
0x7ffcda285cf4 : ap[65] =  65
0x7ffcda285cf8 : ap[66] =  66
0x7ffcda285cfc : ap[67] =  67
0x7ffcda285d00 : ap[68] =  68
0x7ffcda285d04 : ap[69] =  69
0x7ffcda285d08 : ap[70] =  70
0x7ffcda285d0c : ap[71] =  71
0x7ffcda285d10 : ap[72] =  72
0x7ffcda285d14 : ap[73] =  73
0x7ffcda285d18 : ap[74] =  74
0x7ffcda285d1c : ap[75] =  75
0x7ffcda285d20 : ap[76] =  76
0x7ffcda285d24 : ap[77] =  77
0x7ffcda285d28 : ap[78] =  78
0x7ffcda285d2c : ap[79] =  79
0x7ffcda285d30 : ap[80] =  80
0x7ffcda285d34 : ap[81] =  81
0x7ffcda285d38 : ap[82] =  82
0x7ffcda285d3c : ap[83] =  83
0x7ffcda285d40 : ap[84] =  84
0x7ffcda285d44 : ap[85] =  85
0x7ffcda285d48 : ap[86] =  86
0x7ffcda285d4c : ap[87] =  87
0x7ffcda285d50 : ap[88] =  88
0x7ffcda285d54 : ap[89] =  89
0x7ffcda285d58 : ap[90] =  90
0x7ffcda285d5c : ap[91] =  91
0x7ffcda285d60 : ap[92] =  92
0x7ffcda285d64 : ap[93] =  93
0x7ffcda285d68 : ap[94] =  94
0x7ffcda285d6c : ap[95] =  95
0x7ffcda285d70 : ap[96] =  96
0x7ffcda285d74 : ap[97] =  97
0x7ffcda285d78 : ap[98] =  98
0x7ffcda285d7c : ap[99] =  99
#+end_example


