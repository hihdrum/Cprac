#+title: C言語練習

学習の流れ

* 最初のプログラムと仕様情報
** 最初のプログラム「Hello, world!」
最初のプログラムの定番であるハローワールドを作成してみましょう。
適当なテキストエディタを使ってhelloworld.cを作成して下さい。中身は以下のとおりです。

※表記について
$はシェルのプロンプトをプロンプトとなります。シェルにcatコマンドを引数helloworld.cを
渡している状況となりますので、#includeからはhelloworld.cの内容となります。

$ cat helloworld.c 
#include <stdio.h>            /* 最初はおまじない */

int main(void)                /* main関数 : おまじない */
{
  printf("Hello, world!\n");
  return 0;                   /* 関数の戻り値 */
}

プログラムを記述したこの様なファイルをソースコードといいます。
作成できたら、コマンドとして実行できるファイルに変換します。

$ gcc helloworld.c 

a.outというファイルができていたら、以下の様に実行します。

$ ./a.out 
Hello, world!

画面に「Hello, world!」は出力されましたでしょうか。
a.out以外のファイル名にしたい場合は、はオプション-oを使用します。

$ gcc helloworld.c -o helloworld
$ ls helloworld
helloworld

** 実行ファイルができるまでの各工程
テキストファイルから実行可能なファイルになるまでは以下のように
複数の工程に分かれています。

1. プリプロセス(ヘッダファイルの処理など)
 　  $ gcc -E helloworld.c

2. コンパイル(.c -> .S)(アセンブラ)
     $ gcc -S helloworld.c

3. アセンブル(.c -> .o)(オブジェクトファイルの生成)
     $ gcc -c helloworld.c

4. リンク
    自分もよくわかっていないので、詳しくは説明できません。

これらの工程は最初のうちはそこまで気にする必要がありません。
白状しますと、リンクの具体的な動作は私もわかりません。

たいていは、gccまたは、gcc -cの使用で十分と思います。
上記のオプションはgccのマニュアルにも記載があり、ヘルプオプション(gcc --help)でも確認できます。

以下のコマンドを実行し、実際に確認してみて下さい。
$ man gcc
$ gcc --help

マニュアルやヘルプにはアセンブラへの変換をコンパイルと呼んでいますが、会話の中では
実行ファイルの作成までをコンパイルといったり、オブジェクトファイルの作成までをコンパイルと
言ったり様々です。なので、厳密な場合でなければ話の文脈で判断して下さい。

*** 発展:オブジェクトファイルのダンプ
オブジェクトの情報はobjdumpコマンドで見ることができます。

$ gcc -c helloworld.c
$ objdump -d helloworld.o 

helloworld.o:     ファイル形式 elf64-x86-64


セクション .text の逆アセンブル:

0000000000000000 <main>:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # f <main+0xf>
   f:	e8 00 00 00 00       	callq  14 <main+0x14>
  14:	b8 00 00 00 00       	mov    $0x0,%eax
  19:	5d                   	pop    %rbp
  1a:	c3                   	retq 
        ^^^^^^^^^^^^^^^^^^^^^^  ^^^^アセンブラ
        マシン語

-dはディスアセンブルオプションとなっています。左の部分はマシン語になっていて、CPUが理解できる命令になっています。
例えば、オフセット4の0x55は「push %rbp」の命令に対応していことになります。

極端な話をすれば、バイナリエディタで、main部分に出力された内容のデータを作成したものと、gccによって出力された
上記のデータが同じであればmainは同じ動きをします。

** 仕様情報
私はこれまでC言語の仕様を気にしてコードを書いたことはありませんが、この機会に情報を仕入れてみました。
私の環境ではGCCを使用しており、バージョンを以下の用に確認すると9.3.0でした。

$ gcc --version
gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

gccのinfoを見ると「2.1 C Language」には、仕様C11にGNUの拡張を加えたものがデフォルトの
動作になっていると記載がありました。

仕様のドラフト版は以下からダウンロードできるのでダウンロードしてみて下さい。

　　仕様のドラフト

　　  ISO C Working Group (http://www.open-std.org/jtc1/sc22/wg14/)
　　    9899: Programming Language C
　　      C11	ISO/IEC 9899:2011	N1570 [2011-04-04]

N1570のリンクからN1570.pdfが取得できます。

** プログラムの終了状態
シェルは最後に実行したプログラムの終了状態を$?に持っており、echoで値を確認することができます。
true, falseコマンドを例に$?の実行結果を確認してみましょう。

まずは、以下のコマンドでtrueとfalseのマニュアルを確認して下さい。

$ man true
$ man false

マニュアルの関連項目には完全なマニュアルはTexinfoマニュアルとして整備されていると記載があります。
以下のコマンドでinfoを確認して下さい。

$ info true
$ info false

実際にtrue, falseコマンドを実行しマニュアルに記載された通りの終了ステータスが得られることを
確認してみて下さい。

$ true; echo $?
0

$ false; echo $?
1

tureやfalseの他にgrepコマンドなども成功と失敗を返しています。
grepのマニュアルを参照し、どの様な終了ステータスを返すのかを確認してみて下さい。

$ man grep

マニュアルには選択行が見つかった場合は0, 見つからなかった場合は1と記載があります。
見つかる場合と見つからない場合の2ケースを実際に試し終了ステータスを確認して下さい。

$ echo abc | grep a; echo $?
abc
0

$ echo abc | grep d; echo $?
1

C言語では、main関数の戻り値(return 0 の 0)がプログラムの終了ステータスとなります。

** 終了ステータスを返すだけの小さなプログラム
helloworld.cでは画面に文字列を出力(printf)するために、おまじない(#include <stdio.h>)を記述しました。
実はこのおまじないは、画面出力(printf)を使用するために記述しています。プログラムの終了ステータスを返すだけの場合は、
画面出力(printf)が不要なので、このおまじないを取り除くことができます。

以下のreturn0.cを作成し実行させてみなさい。

$ cat return0.c 
int main(void)
{
  return 0;
}

$ gcc -Wall return0.c 
$ ./a.out
$ echo $?
0

このプログラムは--helpや--versionのオプションを受け取れませんが、trueコマンドと同じですね。

** プログラム
C言語の様な手続き型言語のプログラムは平たく言えば、逐一やること書いたものの並びと考えてよいです。
注意点として、コンピュータは基本的に忖度しないので、良きに計らうことが無いので、本当に逐一書くことになります。

最近は、スマホなどのように非常に直感的に動作するものがありますが、高度なプログラミングの集積の上に成り立っていると
考えた方がよいでしょう。

プログラムの記述についてエドガー・ダイクストラが提唱した構造化3定理というものがあります。

  - 順次実行
  - 条件分岐
  - 繰り返し

プログラムの要素はつまるところ、上記の3つで記述できるというものです。

*** 発展:XX指向プログラミング
現在の主流のプログラミングは手続き型で作成されていると考えてよいでしょう。
個人的には、各種言語が関数型の考え方を取り入れて進化していっているという印象を持っています。

世の中には、「XX指向プログラミング言語」という言葉をよく聞いたり、見たりしますが、意味合いとしては
「XX指向プログラミンをサポートする言語」という理解が良いと思います。

XX指向プログラミング言語でプログラムを記述したから、XX指向になるは多くの場合成立しません。
逆を言えば、XX指向プログラミンをサポートシしていない言語でもXX指向のプログラミンは行うことができます。
ただ、言語的なサポートが無いのでサポートしている言語に比べて記述は、しにくくなります。

　- 宣言的
    - 関数型 : Haskell, Erlang(アクター指向)
    - 論理型 : Prolog
    - 手続き的
      - アセンブラ, C
    - オプジェクト指向
      - Smalltalk
    - プロトタイプ指向
      - Javascript, io, 
    - マルチパラダイム
      - Lisp, Java, C++, ...

** 順次実行
C言語は素直に上から下に順次実行されてきますので、処理を上から下に並べて記述すれば順次実行されます。
以下のプログラムを作成し、実際に動作させてみなさい。

$ cat junn.c 
#include <stdio.h>

int main(void)
{
  printf("最初\n");
  printf("次\n");

  return 0;
}

** 問題

   1. 終了ステータス 1 を返すプログラムmyfalseを作成しなさい。

   2. 1 + 2 の計算結果を終了ステータスとして返すプログラムを作成しなさい。

   3. 1から10までの整数の和を終了ステータスとして返すプログラムを作成しなさい。
      (難しく考えず、2. の様に計算機の延長として考えてみよ。)

   4. gccのオプション-Wallについてマニュアルを調べなさい。
      警告を出力してくれるので積極的な利用をおすすめします。

   5. 画面に以下のような文字列を出力するプログラムを作成しなさい。

      $ ./hello2
      hello
      hello

   6. 画面に以下のような文字列を出力するプログラムを作成しなさい。

      $ ./hello3
      hello
       hello
        hello

   7. 画面に以下のような文字列を出力するプログラムを作成しなさい。

      $ ./tree
           *
          * *
         *   *
        *     *
       *********
           *
           *

   8. (質問からの問題)
      シェルスクリプトなどを実行可能にするには、chmodコマンドで実行権を付与するが、
      gccで実行ファイルを実行した場合は最初から実行可能になっている。
   　　なぜですか?

      1. 最初にchmodコマンドが実行ファイルができるまでのどこかの工程で実行されているかもしれない。と予想を立てた。
         プログラムには通常出力しない実行時の詳細情報を出力するオプションを用意している場合がある。
	 gcc に詳細情報を出力する -v または -verbose オプションがあるかをマニュアルから調べてみよ。

	 また、オプションが存在した場合、実際に使用し問題の回答になるかを確かめてみよ。

      2. (関数の後に取り組んだ方がよい)
	 gccはchmodコマンドを呼び出していないようだが、chmodが行っている「ファイルのモードを変更する」という処理と
	 同じ処理を行っているのではないか。と予想を立てた。この「ファイルのモードを変更する」というchmodコマンドの機能は
         何によって実現されているのだろうか。

	 chmodのマニュアルを参照してみよ。特に「関連項目」について見てみよ。

      3. 関連項目の情報から「ファイルのモードを変更する」という機能はchmodシステムコールにより提供されていることが
         わかった。つまり、chmodコマンドはchmodシステムコールを指定したファイルに指定したモードで呼び出すためのコマンドと
	 見ることができる。

	 システムコールをトレースするコマンドstraceがある。straceを使用しchmodシステムコールによって
         実行権が付与されているかを確認してみよ。

* 変数
C言語では変数を使用することができます。
変数には名前(識別子)を付けることができます。このおかげで、保存した値を名前でアクセス(読み取り、書込み)することができます。
変数は、計算結果を一時的に保存するメモの様な物をイメージすればよいでしょう。

** 変数の宣言
変数の使用には予め以下の様に宣言する必要があります。

  保持したい型の情報 名前(識別子) = 初期値;
　　　　　　　　int  x          = 10;    /* int型変数のxの宣言 初期化 */

初期値を指定せずに宣言することもできます。

  保持したい型の情報 名前(識別子);
             int  x;    /* int型変数 x の宣言 */
               x  = 10; /* 代入 */

宣言例は以下となります。

  int weeknum = 7;  /* 一週間の日数 */
  double pi = 3.14; /* 円周率(小数点2桁まで) */
  char good = 'A';  /* 評価 */ /* 文字を記述する場合はクォート(')で囲見ます。*/

C言語は型を意識する言語になっています。
型の情報はメモリ領域の確保や、異なる型の演算をユーザーが誤って記述している場合などのチェックに使われています。
型や変数が使用するメモリ領域のサイズはsizeof(型)やsizeof(変数名)で取得できます。結果はバイト単位です。

*** 整数型 int
1週間の日数を保持するint型の変数を使用する以下のプログラムを作成し、実行してみなさい。

#+NAME: var_int.c
#+BEGIN_SRC C
#include <stdio.h>

int main(void)
{
  int weeknum = 7; /* 一週間の日数 */
  printf("weeknum = %d\n", weeknum);

  printf("sizeof(int) = %zd\n", sizeof(int));
  printf("sizeof(weeknum) = %zd\n", sizeof(weeknum));

  return 0;
}
#+END_SRC

#+RESULT: var_int.c
$ gcc -Wall var_int.c -o var_int
$ ./var_int 
weeknum = 7
sizeof(int) = 4
sizeof(weeknum) = 4

**** 問題
1. var_int.cは初期値を指定した変数の宣言方法であった。初期値を指定しない場合、変数の値に何か入っているかを確認するプログラムを
   var_int.cを参考に作成しなさい。

2. int型には他にshort int, long intなどの型がある。これらの型の変数について、サイズを確認してみよ。

*** 文字型 char
文字を保持するchar型の変数を使用する以下のプログラムを作成し、実行してみなさい。

#+NAME: var_char.c
#+BEGIN_SRC C
#include <stdio.h>

int main(void)
{
  char a = 'a';
  printf("a = %c\n", a);

  printf("sizeof(char) = %zd\n", sizeof(char));
  printf("sizeof(a) = %zd\n", sizeof(a));

  return 0;
}
#+END_SRC

#+RESULT: var_char.c
$ gcc -Wall var_char.c -o var_char
$ ./var_char 
a = a
sizeof(char) = 1
sizeof(a) = 1

文字型という型ですが、sizeof(char)の結果を見るようにサイズは1バイトです。
そのため、多バイト文字を扱おうとするとコンパイル時に警告が出ます。
1バイトサイズの変数を保持する型と保持する型と覚えればいいでしょう。

*** 実数型 float
実数値を保持するfloat型の変数を使用する以下のプログラムを作成し、実行してみなさい。

#+NAME: var_float.c
#+BEGIN_SRC C
#include <stdio.h>

int main(void)
{
  float f = 1.142;
  printf("f = %f\n", f);

  printf("sizeof(float) = %zd\n", sizeof(float));
  printf("sizeof(f) = %zd\n", sizeof(f));

  return 0;
}
#+END_SRC

#+RESULT: var_float.c
$ gcc -Wall var_float.c -o var_float
$ ./var_float 
f = 1.142000
sizeof(float) = 4
sizeof(f) = 4

C言語では整数と実数はメモリ上の表現が異なりますので、1と1.0の扱いは異なります。

**** 問題
1. float型の変数に整数値を代入するプログラムを作成しなさい。
2. int型の変数に実数値を代入するプログラムを作成しなさい。
3. printfでは整数型を指定する場合%d, 実数型を指定する場合%fを使用してきたが、
   整数型の変数を%fで、実数型を%dで出力させてみよ。
4. 変数の前に(型)変数と記述することでコンパイラに型を強制することができ、キャストという。
   キャストを使用し、警告がでなくなることを確認せよ。
5. printfの精度オプションを使用し小数点2桁表示で実数型の値を出力させてみよ。

***** 問題3について(C言語の学習とは関係ない領域)
問題3の説明にて%d,%fでprintfのメモリ解釈が変わるため結果が変わると説明したが、
次の質問がでた。メモリの解釈が変わるだけならば、実行時にメモリ内容は指定しているので、
実行のたびに値は変化しないはずだ。実行のたびに値が変化しているので、確かに指摘のとおりである。

結論としては、printfは%f指定時にはxmmに指定した値を元に出力データを得ており、
%d指定時にはesiを元に出力データを得ているようであった。そのため、%d指定で、
float型の変数を渡した場合、printfはesiの情報を参照する。オブジェクトコードを
見ると、printfの呼び出し前にesiへの操作は無かった。つまり、esiにはゴミ情報が
入っていることになる。そのため、実行のたびに値が変化していた。

調査にあたって確認したもの。
  1. gccにより生成されたオブジェクトコードの確認
  2. 以下のパターンの比較
     1. %d に float型
     2. %f に float型
     3. %d に int型

** 配列
C言語には配列というデータ構造た用意されており、同じ様なデータを扱うのに利用できます。
以下の様に記述します。

  保持したい型の情報 名前(識別子)[要素数] = { 値1, 値2, ... };
              int ia[3] = { 1, 2, 3 };

配列の場合も値を指定せずに宣言することができます。

  保持したい型の情報 名前(識別子)[サイズ];
              int ia[] = { 1, 2, 3 };

例

  float weights[3] = { 55.5, 60.0, 70.2 } /* 3つの体重 */
  char hello[] = { 'H', 'e', 'l', 'l', 'o', '\0'} /* 文字列Hello */ /* '\0' は文字列の終端 */
  char hello2[] = "Hello"; /* 上と同じ */ /* 文字列はダブルクォート(")で囲む */

保持した情報へのアクセス時は0オリジン(0から数え始める)で[]の中に場所を整数値で指定します。
この整数値のことを、添え字やインデックスといいます。

  weighs[0]  <-- 55.5

指定範囲外へのアクセスはプログラムの異常動作に繋がりますので、注意しましょう。

*** int型の配列
int型の配列を使用する以下のプログラムを作成し、実行してみなさい。

#+NAME: array_int.c
#+BEGIN_SRC C
#include <stdio.h>

int main(void)
{
  int score[3] = { 10, 19, 17 };
  printf("score[%d] = %d\n", 0, score[0]);
  printf("score[%d] = %d\n", 1, score[1]);
  printf("score[%d] = %d\n", 2, score[2]);

  printf("sizeof(score) = %zd\n", sizeof(score));

  return 0;
}
#+END_SRC

#+RESULT: array_int.c
$ gcc -Wall array_int.c -o array_int
$ ./array_int 
score[0] = 10
score[1] = 19
score[2] = 17
sizeof(score) = 12

**** 問題
1. int型、要素数3の配列を宣言し、最初の2要素だけ初期化した場合、3番目の要素(インデックス2)にどの様な値が
   入っているかを確認するプログラムを作成せよ。
2. char型の配列helloを宣言し以下の様にデータを設定し、内容を出力させてみよ。
   番目 : データ
     0 : 'H'
     1 : 'e'
     2 : 'l'
     3 : 'l'
     4 : 'o'
     5 : '\0'
3. 上記のプログラムに変換指定子%sを使用するprintfを追加しhelloを出力させてみよ。

** 紹介していない型
「6.7.2 Type specifiers 2」

** printf
printfは画面にプログラムの情報を出力するのに使うことができます。
学び始めの段階では、実際のプログラムの動作と自分の頭のプログラム動作とが一致しないことが多くあります。
その際、処理の間にprintfを挿入し状況を見ていくというのはプログラムの理解を助けます。

実業務でプログラムを書くようになっても自分の頭とプログラムの動作が一致しないことは日常的に起きます。
つまりは、バグを入れ込んだということです。

慣れてくると、printfではなくデバッガを使ってプログラムの動作を確認する方法を取ることもありますが、
どちらの方法をとるかは状況によります。printfの出力に慣れていて損はないので、ぜひ色々と出力させてみて下さい。

*** マニュアル
printfのマニュアルを以下の様に調べるとpritfコマンドについての内容が出てきます。

$ man printf

この様な場合はセクション情報も指定します。

$ man 3 printf

各セクションの情報はmanコマンドのマニュアルで確認できます。
C言語での開発時によく見るのは以下のセクションとなります。

       2   システムコール (カーネルが提供する関数)
       3   ライブラリー呼び出し (プログラムライブラリーに含まれる関数)

インフラ系の人はセクション5のお世話になっているかもしれないですね。(man  hostsなど)

       5   File formats and conventions, e.g. /etc/passwd

** コメント
ソースコード中にはプログラムの動作に影響しないメモとしてコメント記述することができます。

学習時にはプログラムの動作をメモしてみるというのも一つの方法かもしれません。
コメントについては格言もあり、「書かれしことを書くな。書かざれしことを書け」というものがあります。
プログラムが語っている動作をコメントに書く必要は無い。しかし、プログラムが語れないことはコメントとして
書くべきとの格言です。

*** 1行コメント
   // ........

*** 複数行対応
   /* xxxxxx */

   /* 
      aaaaaa
      zzzzzz
    */

*** その他
プリプロセスを利用した例

#if 0

  #if から #endif までのコードが無効になります。

#endif

*** 仕様

「6.4.9 Comments」も合わせて参照してみて下さい。

* 関数
関数(function)には、機能や働きという意味があります。C言語における関数も同じで機能や働きを実現するために使用します。
例えば、printf関数は、指定された書式(f:format)で出力(print)する機能を持っています。

** 関数と抽象化
関数の利点のひとつに指定された使い方を守れば、その機能を利用できるという点があります。
利用にあたっては、関数がどの様に実装されているかは気にする必要がありません。

実生活の中ではこの様なものが多くあります。
例えば、洗濯機ではどのように洗濯するかをボタンで選んでスタートを押せば、洗濯をしてくれます。
利用者は洗濯機が洗濯槽のモーターの電流をどの様に制御しているかは普通知らないと思いますが、洗濯機は使えているはずです。

これは、一種の抽象化といえます。具体的なレベルではモーターの電流などを考えなければいけませんが、
幾つかの回路などを組みあせて、モータ制御部が組み上がり、抽象度が上がっていき、最終的にボタン入力で洗濯ができる。という
段階まできているわけです。

関数を定義していくことは抽象化の層を作っているという感じです。

抽象度高 <----> 抽象度低
洗濯する。
  ボタン入力で洗濯メニューをコントロールする。
    指定メニューに合わせて洗濯機の動作を制御する。
      指定の水位まで水をいれる。
        水の流入口を開く。
      モータの回転を制御する。
        時間経過で逆回転にする。
  :

** 関数定義
戻り値の型 関数名(引数の型 引数の名前)　/* プロトタイプ宣言に使用する部分 */
{
  各種処理;

  return 戻り値;
}

引数が不要な場合はvoidを記述します。
戻り値が不要な場合は戻り値の型を void とします。
戻り値の型がvoidの場合はreturnを省略できます。または、return;とします。

これまで記述したmain関数を見直し見ると上記の形式にちゃんと合っています。

以下はint型の引数に1を加えて返す関数の例である。実際に記述し実行してみよ。

#+NAME: add1.c
#+BEGIN_SRC C
#include <stdio.h>

int add1(int x)
{
  return x + 1;
}

int main(void)
{
  int x = 10;
  printf("x + 1 = %d\n", add1(x));

  int x1 = add1(x);
  printf("x1 = %d\n", x1);

  return 0;
}
#+END_SRC

#+RESULT: add1.c
$ gcc -Wall add1.c -o add1
$ ./add1 
x + 1 = 11
x1 = 11

*** 問題
1. 常に失敗(0)を返す関数falseを作成し実際に使用してみよ。(false.c)
2. float型の引数を受け取り、その値の2乗を返す関数square_floatを作成し、実際に使用してみよ。
3. float型の引数を受け取り、その値の3乗を返す関数cube_floatを作成し、実際に使用してみよ。
   作成にあたり、square_floatを利用せよ。
4. float型の引数を受け取り、その値の4乗を返す関数quad_floatを作成し、実際に使用してみよ。
   作成にあたり、square_floatを利用せよ。
6. 2つの整数の和を計算する関数addを作成し実際に使用してみよ。(add.c)
5. Hello, world!と画面に出力する関数printHelloを作成しなさい。

*** プロトタイプ宣言
C言語ではファイルの先頭側で定義した関数1からファイルの後の方で定義した関数2を使用すると、
コンパイル時に警告:暗黙の型宣言がでます。これは、関数1のコンパイル時に関数2の型情報が無いために、
コンパイラが「型の情報が無いのでわかりません〜」と言っているわけです。

この様な問題を回避するため、関数の型情報をプロトタイプ宣言としてファイルの先頭の方に記述します。
プロトタイプ宣言は関数定義の一部を記述します。

以下は実際に暗黙の型宣言(implicit declaration)の警告を出力させた例である。
実際に記述し実行してみよ。

#+NAME: implicit.c
#+BEGIN_SRC C
int main(void)
{
  return f();
}

int f(void)
{
  return 1;
}
#+END_SRC

#+RESULT: implicit.c
$ gcc -Wall implicit.c 
implicit.c: In function ‘main’:
implicit.c:3:10: warning: implicit declaration of function ‘f’ [-Wimplicit-function-declaration]
    3 |   return f();
      |          ^

以下はプロトタイプを宣言(プロトタイプ宣言)したことで、暗黙の型宣言の警告がでなくなった例である。
実際に記述し実行してみよ。

#+NAME: prototype.c
#+BEGIN_SRC C
int f(void); /* プロトタイプ宣言 */

int main(void)
{
  return f();
}

int f(void) /* 関数定義 実装部分 */
{
  return 1;
}
#+END_SRC

#+RESULT: prototype.c
$ gcc -Wall prototype.c 

*** ヘッダファイル
ヘッダファイル(*.h)にはプロトタイプ宣言が記述されています。
includeには、入れるや含めるという意味があります。これまで記述していた#include <stdio.h>は
stdio.hの内容を含めるという意味になります。含めていたのは、ものにはプロトタイプ宣言が入っています。

試しに#include <stdio.h>の行を削除すると、printfで「implicit declaration」が出ます。

**** 問題
1. Hello, world!と画面に出力するプログラムを作成しなさい。
   出力にはprintf関数を使用せよ。
2. 作成したプログラムから#include <stdio.h>を削除し暗黙の型宣言の警告が出力されるか試してみなさい。
3. stdio.hからprintfに関するプロトタイプ宣言を抜き出すとどうなるだろうか。試してみなさい。

** モジュール, ライブラリ

- 実行ファイルにはmain関数がただ1つだけ含まれる。
- モジュール *.c
- ライブラリ
  .oを集めて、.hを提供したもの。

  - 静的 :  .a  リンク時に実行ファイルに含まれる。
  - 共有 : .so　実行時にダイナミックリンクされて実行される。

** 仕様
「6.9.1 Function definitions」
「6.10.2 Source file inclusion」

** 問題
1. 角度を度数の単位からラジアン単位に変換する関数を実装しなさい。
   円周率は、math.hのM_PIを使用しなさい。

2. mathライブラリのfloat powf(float x, float y)の結果を利用し、2,3,4乗を計算させてみよ。
   前の問題でXXXX_float関数を実装済なら計算結果を比較してみよ。

3. 数値文字を受け取り整数値として返す関数を実装しなさい。
   実装につまる場合は以下を試してみなさい。

   1. 0から9の数字文字をprintfの10進表記で出力させてみよ。

   2. 出力された結果から文字と値の関係性を考えてみよ。

4. 標準入力から文字を取得する以下の関数を使ってみよ。
   使用にあたり以下のマニュアルを確認せよ。

   $ man getchar

* 条件分岐
これまでのプログラムは関数の呼び出しはあるものの、実行順序は基本的に上から下への流れでした。
ここからは、順次実行に加えて構造化3定理の条件分岐を加えていきます。

条件分岐とは、条件が成立した場合だけ、処理を行う。というように処理を行うかどうかを制御する能力のことです。
出勤時に傘を持参するかどうかを判定する例を考えてみます。

  1. 出勤前に天気予報を確認する。
  2. 天気予報の降水確率が75%以上かどうかを確認する。
  3. 75%以上の場合、傘を持参する。
  4. 75%未満の場合、傘は持たない。

という様に傘を持参するかどうかを天気予報で変えたりしていると思います。
2の降水確率の結果によって、3または4に処理が分かれる部分がこれまでのプログラムとの違いとなります。

最初に条件判定に利用する演算子に付いて練習した後に、処理が分岐するプログラムを記述してみます。

** 条件判定に利用する演算子

#+NME: eop01.c
#+BEGIN_SRC C
#include <stdio.h>

int main(void)
{
  int x = 1;
  int y = 1;
  printf("(%d == %d) = %d\n", x, y, x == y);

  y = 2;
  printf("(%d == %d) = %d\n", x, y, x == y);

  return 0;
}
#+END_SRC

#+RESULT: eop01.c
$ gcc -Wall eop01.c 
$ ./a.out 
(1 == 1) = 1
(1 == 2) = 0

*** 仕様
「6.5.9 Equality operators」

*** 問題
1. 「6.5.9 Equality operators」には、等しいかどうかを判定する==の他に、
    等しくないことを判定する!=が記載されている。!=を実際に使用してみよ。

2. 「6.5.8 Relational operators」には、大小関係を判定する一連の演算子について記述がある。
   1. < を実際に使用してみよ。
   2. > を実際に使用してみよ。
   3. <= を実際に使用してみよ。
   4. >= を実際に使用してみよ。

3. より複雑な判定行う場合ために、条件を組み合わせる論理積(「6.5.13 Logical AND operator」)と
   論理和(6.5.14 Logical OR operator)」が用意されている。

   1. && を実際に使用してみよ。
   2. || を実際に使用してみよ。

以下は整数を受け取り偶数かどうかを判定するプログラムの例である。
実際に記述し実行してみよ。

** 選択文

#+NAME: iseven01.c
#+BEGIN_SRC C
#include <stdio.h>

int isEven(int x)
{
  int isEven = 0; /* 0:奇数, 1:偶数 */
  if(x % 2 == 0)
  {
    isEven = 1;
  }

  return isEven;
}

int main(void)
{
  int x = 5;
  printf("isEven(%d) = %d\n", x, isEven(x));

  x = 6;
  printf("isEven(%d) = %d\n", x, isEven(x));

  return 0;
}
#+END_SRC

#+RESULT: iseven01.c
$ gcc -Wall iseven01.c
$ ./a.out
isEven(5) = 0
isEven(6) = 1

** 仕様
「6.8.4 Selection statements」

** if
xが成立する場合に、処理2を実行する。

  処理1;

  if(x)
  {
     /* xが成立する場合、ここが実行される。*/
     処理2;
  }

  処理3;

** if〜else
xが成立する場合、に処理2が実行され、xが成立しない場合に処理3を実行する。

  処理1;

  if(x)
  {
     /* xが成立する場合、ここが実行される。*/
     処理2;
  }
  else
  {
     /* xが成立しない場合、ここが実行される。*/
     処理3;
  }

  処理4;

以下は整数を受け取り偶数かどうかを判定するプログラムの例である。
実際に記述し実行してみよ。

#+NAME: iseven02.c
#+BEGIN_SRC C
#include <stdio.h>

/* 0:奇数, 1:偶数 */
int isEven(int x)
{
  if(x % 2 == 0)
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

int main(void)
{
  int x = 5;
  printf("isEven(%d) = %d\n", x, isEven(x));

  x = 6;
  printf("isEven(%d) = %d\n", x, isEven(x));

  return 0;
}
#+END_SRC

#+RESULT: iseven02.c
$ gcc -Wall iseven02.c
$ ./a.out
isEven(5) = 0
isEven(6) = 1

** if〜else if〜 else〜else
xが成立した場合、処理2が実行される。
yが成立した場合、処理3が実行される。
yも成立しない場合、処理4が実行される。

  処理1;

  if(x)
  {
    /* xが成立する場合、ここが実行される。*/
    処理2;
  }
  else if(y)
  {
    /* xが成立しない。かつyが成立する場合、ここが実行される。*/
    処理3;
  }
  else
  {
    /* xが成立しない。かつyが成立しない場合 */
    /* 上記以外の場合、ここが実行される。*/
    処理4;
  }

  処理5;

以下はテストの点数を受け取り評価A〜Eを返すプログラムの例である。
実際に記述し実行してみよ。

#+NAME: evalTest.c
#+BEGIN_SRC C
#include <stdio.h>

char evalTest(int x)
{
  if(75 <= x)
  {
    return 'A';
  }
  else if(50 <= x)
  {
    return 'B';
  }
  else if(25 <= x)
  {
    return 'C';
  }
  else
  {
    return 'D';
  }
}

int main(void)
{
  int x = 100;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 74;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 49;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 24;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  return 0;
}
#+END_SRC

#+RESULT: evelTest.c
$ ./a.out
evalTest(100) = A
evalTest(74) = B
evalTest(49) = C
evalTest(24) = D

** if〜else if
xが成立する場合、処理2が実行される。
yが成立する場合、処理3が実行される。

  処理1;

  if(x)
  {
    /* xが成立する場合、ここが実行される。*/
    処理2;
  }
  else if(y)
  {
    /* xが成立しない。かつyが成立する場合、ここが実行される。*/
    処理3;
  }

  処理4;

以下はテストの点数を受け取り評価A〜Eを返すプログラムの例である。
実際に記述し実行してみよ。

#+NAME: evalTest01.c
#+BEGIN_SRC C
include <stdio.h>

char evalTest(int x)
{
  if(75 <= x)
  {
    return 'A';
  }
  else if(50 <= x)
  {
    return 'B';
  }
  else if(25 <= x)
  {
    return 'C';
  }

  return 'D';
}

int main(void)
{
  int x = 100;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 74;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 49;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  x = 24;
  printf("evalTest(%d) = %c\n", x, evalTest(x));

  return 0;
}
#+END_SRC

#+RESULT: evalTest01.c
$ gcc -Wall evalTest01.c
$ ./a.out
evalTest(100) = A
evalTest(74) = B
evalTest(49) = C
evalTest(24) = D

*** 問題
1. 以下のような入園料を計算するプログラムを作成せよ。

   65歳以上 : 無料
   18歳以上 : 1800
   18歳未満 : 1200

2. 以下のように性別と年齢で料金を決めるプログラムを作成せよ。

   男性, 6歳以上 : 1000
   女性, 6歳以上 :  800
   男性, 6歳未満 :  200
   女性, 6歳未満 :  200

3. 小文字(a〜z)を大文字(A-Z)に変換するプログラムを作成せよ。


** switch

   switch(x)
   {
     case 定数1:
     　処理1;
       処理1-2;
       break;

     case 定数2:
       処理2;
       break;

     default:
       その他処理;
   }

以下は評価A〜Dを数値4〜1に変換するプログラムである。
実際に記述し実行してみよ。

#+NAME: ab2num.c
#+BEGIN_SRC C
#include <stdio.h>

int ab2num(char e)
{
  int num;
  switch(e)
  {
    case 'A':
      num = 4;
      break;

    case 'B':
      num = 3;
      break;

    case 'C':
      num = 2;
      break;

    default:
      num = 1;
  }

  return num;
}

int main(void)
{
  char e = 'A';
  printf("ab2num(%c) = %d\n", e, ab2num(e));

  e = 'B';
  printf("ab2num(%c) = %d\n", e, ab2num(e));

  e = 'C';
  printf("ab2num(%c) = %d\n", e, ab2num(e));

  e = 'D';
  printf("ab2num(%c) = %d\n", e, ab2num(e));

  return 0;
}
#+END_SRC

#+RESULT: ab2num.c
$ gcc -Wall ab2num.c
$ ./a.out
ab2num(A) = 4
ab2num(B) = 3
ab2num(C) = 2
ab2num(D) = 1

switch文はbreakを記述しない場合、上から下に処理が行われていきます。

以下は評価A〜Dから合否を判定するプログラムである。
実際に記述し実行してみよ。

#+NAME: isOk.c
#+BEGIN_SRC C
#include <stdio.h>

int isOk(char e)
{
  int isOk;
  switch(e)
  {
    case 'A':
    case 'B':
      isOk = 1;
      break;

    case 'C':
    default:
      isOk = 0;
  }

  return isOk;
}

int main(void)
{
  char e = 'A';
  printf("isOk(%c) = %d\n", e, isOk(e));

  e = 'B';
  printf("isOk(%c) = %d\n", e, isOk(e));

  e = 'C';
  printf("isOk(%c) = %d\n", e, isOk(e));

  e = 'D';
  printf("isOk(%c) = %d\n", e, isOk(e));

  return 0;
}
#+END_SRC

#+RESULT: isOk.c
$ gcc -Wall isOk.c
makoto@insp-7380:~/gitHub/Cprac$ ./a.out
isOk(A) = 1
isOk(B) = 1
isOk(C) = 0
isOk(D) = 0

*** 問題
1. isOk.cをif,else if, elseを使用し書き直してみなさい。

** 仕様

「6.8.4 Selection statements」

** 関数型スタイルと再帰
変数への代入を行わないプログラミングに関数型プログラミンがあります。
C言語は関数型のプログラミング言語ではありませんが、関数型プログラミングのスタイルでコードを記述することはできます。
ただし、関数型プログラミング言語の様に関数が第1級オブジェクトではないため、制限があります。
関数型の数学的な記述に近いかたちでコードを記述でき、1つの利点と言われています。

C言語では関数呼び出し時にスタックを使用します。そのため、再帰が深くなりスタックが枯渇するとプログラムが異常終了します。
関数型言語でもスタック同じことは起きますが、末尾再帰の形で記述した再帰処理がgotoになる処理系もありスタックを消費しないコードになります。

以下は再帰を用いて階乗を計算するプログラムとなります。

 fact_rec(0) = 1                  (n == 0)
 fact_rec(n) = n * fact_rec(n-1)  (n != 0)

実際に記述し実行してみよ。

#+NAME: fact_rec.c
#+BEGIN_SRC C
#include <stdio.h>

int fact_rec(const int x)
{
  if(0 == x)
  {
    return 1;
  }
  else
  {
    return x * fact_rec(x - 1);
  }
}

int main(void)
{
  int x = 5;
  printf("fact(%d) = %d\n", x, fact_rec(x));

  return 0;
}
#+END_SRC

#+RESULT: fact_rec.c
$ gcc -Wall fact_rec.c
$ ./a.out
fact(5) = 120

** 問題
1. 消費税を計算する関数 int calcTaxを作成せよ。(calcTax.c)
   税率は,軽減税率対象 8%, その他は10%とせよ。
   小数点の扱いは好きにしてよいものとする。

2. 水量を管理するユーザーからの依頼(適当なでっち上げストーリーです。)

   1. ユ:管理しているタンクの水量が一定量に達した場合に警告を出してほしい。
	 
         ユーザーへの要望に応えるために、警告を発するかどうかの判定関数を
	 用意するこになった。実装してみよ。

   2. ユ:実は、タンクの水量は入と排出の量が常に変動しており、現在だと、警告値付近で警告が頻繁に
　　　　　出たり止まったりする。一度警告状態となったら、ある程度水量が下がった後に警告を解除する様にしてほしい。

        実装してみよ。

3. 0からnまでの整数の和を求める関数を再帰呼び出しを使い実装せよ。
   具体的にすると

   sum(10) = 10 + sum(9)
                  9 + sum(8)
                      8 + sum(7)
      :

   実装に詰まる場合は、fact_recを参考にせよ。(sum_rec.c)

4. FizzBuzz問題
   1. FizzBuzz問題を解くにあたり、ある整数について処理を行う関数を用意することにした。
      void printFizzBuzz(int)のを実装せよ。

      void printFizzBuzz(int)の仕様
        intの値     : 出力する文字列
        3の倍数の場合 : Fizz
        5の倍数の場合 : Buzz
       15の倍数お場合 : FizzBuzz
        それ以外の場合 : 数値そのまま

   2. main関数を以下に置き換えてプログラムを実行してみよ。(fizzBuzzMain.c)

#+begin_src C
int main(int argc, char *argv[])
{
  int num = atoi(argv[1]);
  printFizzBuzz(num);

  return 0;
}
#+end_src

#+result
$ gcc -Wall fizzBuzzMain.c 
$ seq 30 | while read x; do ./a.out $x; echo -n " "; done
1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz 

* 繰り返し
** while

  while(継続条件)
  {
    /* 継続条件成立時 */

    /* 継続条件更新 */
  }

以下は0からnまでの整数の和を求めるプログラムである。
実際に記述し実行してみよ。

#+begin_src C
#include <stdio.h>

int sumWhile(int n)
{ 
  int sum = 0;
  int i = 0;
  while(i <= n)
  {
    sum += i;
    i++;
  }
  
  return sum;
}

int main(void)
{ 
  printf("%d\n", sumWhile(10));

  return 0;
} 
#+end_src

#+result
$ gcc -Wall sumWhile.c 
$ ./a.out 
55

** for

  for(初期化; 継続条件; 継続条件更新)
  {
  }

以下は0からnまでの整数の和を求めるプログラムである。
実際に記述し実行してみよ。

#+begin_src C
#include <stdio.h>

int sumFor(int n)
{ 
  int sum = 0;
  int i;
  for(i = 0; i <= n; i++)
  { 
    sum += i;
  } 
  
  return sum;
}

int main(void)
{ 
  printf("%d\n", sumFor(10));

  return 0;
} 
#+end_src

#+result
$ gcc -Wall sumFor.c 
$ ./a.out 
55

** 仕様
「6.8.5 Iteration statements」

** 問題

  1. 掛け算九九を出力するプログラムを作成せよ。

  2. 九九を拡張し、16x16の掛け算結果を出力するプログラムを作成せよ。
     出力は16進数にせよ。

  3. 図形の描画
     図形を描画するプログラムを作成せよ。
     なお、問題を解くにあたり必要な関数は自由に実装せよ。

     元ネタ：「明解 C言語」

     1. 横棒 3指定

	***

     2. 四角形 4,2指定

	*****
	*****

     3. 直角三角形

	1. 4指定

	   * 
	   **
	   ***
           ****

	2. 4指定

	      * 
             **
            ***
           ****

     4. 二等辺三角形 3指定

　　　　　　* 
	 ***
        *****

     5. 平行四辺形 5,3指定

        *****
         *****
          *****

  1. 複利計算

     元金,年利,年数を指定して各年毎の元金を表示させてみよ。

  2. 標準入力から入力されたバイト数をカウントし結果を出力するプログラムを作成せよ。
     作成したプログラムの結果とwc -c の結果を比較してみよ。

  3. 標準入力から入力された文字を16進数で出力するプログラムを作成せよ。
     作成したプログラムの結果とodやhexdumpの結果を比較してみよ。

  4. 整数の配列から最大値の情報を返す関数を実装し、main関数から呼び出してみなさい。

* ポインタ
** 説明1
言葉について考えてみます。ポインタ(pointer)とはポイントするものです。

例えば、プレゼンテーションでは、説明者がプロジェクターで映し出された資料を指す(ポイントする)ために
レーザーポインタを使用したりします。つまり、(レーザー)ポインタは資料を指すものです。

C言語におけるポインタが何を指しているかというと、メモリアドレスを指しています。

これまで、使用してきた変数は基本的に各型に対応する値を保持していました。
変数はメモリ上に保存されていますが、特にメモリアドレスを意識せずに使用してきました。

  int x = 10;   /* int型の変数xは10という値を保持している。変数にアクセスする際は、識別子xを指定する。 */
  char c = 'A'; /* char型の変数cは'A'という値を保持している。変数にアクセスする際は、識別子cを指定する。*/

ポインタを使用することによって、これまで意識してこなかったメモリアドレスについて意識する必要が出てきますが、
代わりにプログラマがメモリアドレスを意識したプログラムを記述することができます。

  int *px;      /* int型の値を指すメモリアドレスを保持する変数px */
  px = &x;      /* 変数xのアドレスを変数pxに保持する。         */
  *px;          /* pxが変数xのアドレスを指しているので、*pxの値は、xの値となる。*/

  char *pc = &c; /* char型の値を指すメモリアドレスを保持する変数pcに変数cのアドレスを保持する。*/
  *pc;           /* pcが変数cのアドレスを指しているので、*cの値はcの値となる。*/

&はリファレンス(reference)、*はリファレンスの逆、デリファレンス(dereference)といいます。

ポインタは、メモリを直接扱うということからも低級(低レベル)の機能といえます。
そのため、ポインタの有効性を理解するには、C言語だけではなく低レベルの機能についての理解が必要になります。

ここでは、低レベルの機能について説明は、行わずポインタの使用例上げていきたいと思います。

** 説明2
ポインタ型の変数とは、アドレスを保存する変数です。現実の住所と比較してコメントを入れてみます。

/* ハインツ川崎 : 10階建 */
int x = 10; /* 住所の情報は見えない。(意識しなくてよい。) */

/* ハインツ川崎の住所を得るには &x とする。*/
/* &x 神奈川県 川崎市1番地 である。*/
   &x

/* ハインツ川崎 住所保存用の変数を用意する。*/
int *px;

/* 変数 px に ハインツ川崎の住所(&x : 神奈川県 川崎市1番地)を代入する。*/
int *px = &x;

/* 住所(神奈川県 川崎市1番地)の建物を 20階建にする。*/
*px = 20;

** ポインタの使用例(理解に向けて)
以下のプログラムはポインタの理解を助けることを目的としたプログラムです。
実際に記述し実行し結果を確認してみて下さい。

#+NAME: pointer01.c
#+BEGIN_SRC C
#include <stdio.h>

int main(void)
{
  int x = 10;
  int *px = &x;

  printf("xの値:%d, xのメモリアドレス:%p\n", x, &x);
  printf("pxの値:%p, pxのメモリアドレス: %p, pxが指すメモリアドレスに保持している値:%d\n",px, &px, *px);

  return 0;
}
#+END_SRC

#+RESULT: pointer01.c
$ gcc -Wall pointer01.c
$ ./a.out
xの値:10, xのメモリアドレス:0x7ffe40e0ce9c
pxの値:0x7ffe40e0ce9c, pxのメモリアドレス: 0x7ffe40e0cea0, pxが指すメモリアドレスの値:10

上記の結果を整理してみます。
                                 
名前, メモリに保持する値,  　　メモリアドレス(これまで意識してこなかった部分)
  x,              10,   0x7ffe40e0ce9c
 px,  0x7ffe40e0ce9c,   0x7ffe40e0cea0

xの値を取得するには、識別子xでアクセスし、メモリの保持する値10を得る。(これまで)
pxの値を取得するには、識別子pxでアクセスし、メモリの保持する値0x7ffe40e0ce9cを得る。(ポインタ)

識別子(xやpx)で値にアクセスするのはこれまでと同じです。
これはでは、整数値や実数値、文字を取得していましたが、これにメモリアドレスが加わります。

  リファレンス  &x =   0x7ffe40e0ce9c  = px
               x = *(0x7ffe40e0ce9c) = *px デリファレンス

** ポインタの理解(同一アドレスの更新)

#+NAME: pointer02.c
#+BEGIN_SRC C
#include <stdio.h>

int main(void)
{
  int x = 10;
  int *px = &x;

  printf("x = %d, *px = %d\n", x, *px);

  x = 11;
  printf("x = %d, *px = %d\n", x, *px);

  *px = 12;
  printf("x = %d, *px = %d\n", x, *px);

  return 0;
}
#+END_SRC

#+RESULT: pointer02.c
$ gcc -Wall pointer02.c
$ ./a.out
x = 10, *px = 10
x = 11, *px = 11
x = 12, *px = 12

pxがxのアドレスを保持しているので、xと*pxで同じ結果となっています。

** 呼び出し先関数で引数の値を更新する

#+name: pointer03.c
#+begin_src C
#include <stdio.h>

void funcNG(unsigned char x)
{
  x = 0xff;
}

void funcOK(unsigned char *x)
{
  *x = 0xff;
}

int main(void)
{
  unsigned char x = 0xaa;

  funcNG(x);
  printf("x = %x\n", x);

  funcOK(&x);
  printf("x = %x\n", x);

  return 0;
}
#+end_src

#+result: pointer03.c
$ gcc -Wall -g pointer03.c 
$ ./a.out 
x = aa
x = ff

funcNG内でx=0xffを実行していますが、xの結果は変化せずに0xaaとなっています。
関数の呼び出し時には呼び出し元の引数が保持する値のコピーが渡されます。そのため、
コピーされた値を呼び出し先で変更しても、呼び出し元には影響しません。

不便に思うかも知れませんが、呼び出し元の変数に影響を与えないことは利点です。
ただ、変更したい場合もあるのでその様な場合は呼び出し元のメモリアドレス情報を
渡すわけです。

** scanfの使用例

#+name : sampel_scanf01.c
#+begin_src C
#include <stdio.h>

int main(void)
{
  printf("整数値を入力して下さい : ");

  int in;
  scanf("%d", &in);

  printf("入力された整数値は、%dでした。\n", in);

  return 0;
}
#+end_src

#+name : sample_scanf02.c
#+begin_src C
#include <stdio.h>

int main(void)
{
  printf("整数値を入力して下さい : ");

  int in;
  int *pin = &in;

  scanf("%d", pin);

  printf("入力された整数値は、%dでした。\n", in);
  printf("入力された整数値は、%dでした。\n", *pin);

  return 0;
}
#+end_src

*** 問題
1. pointer03.cを修正し各種変数のメモリアドレス情報を出力させてみよ。

2. char型要素数4の配列ca[4]を用意し、各値のアドレスと値を表示させてみよ。
   表示にはcaのアドレスを含めよ。また、文字型のポインタを用意し、配列の
   添字との関係性を見てみよ。

3. 整数の割り算の商と余りを返す関数
4. 数値配列に変更加える。
5. 数値配列の値を変更した結果を別の配列に入れる。
7. 文字列を走査し指定した文字の位置を返す関数
8. 配列から指定した条件に一致したものと、一致しなかったものを返す
9. scanfを利用してみる。簡易的なcsv入力
10. 数値配列に対して、qsortを利用してみよ。
11. 和の関数シグマを定義せよ。
12. 積の関数パイを定義せよ。

* 構造体,共用体
別の種類のデータを一つにまとめたもの

** 宣言
struct タグ名
{
  型名 メンバ名;
  :
};

** 使用時

 struct タグ名 変数名;

 変数名.メンバ名

** 仕様

「6.7.2.1 Structure and union specifiers」

** 問題 
   1. 2次元デカルト座標系を表現するために構造体を利用してみよ。
   2. 単方向リストを実装してみよ。
   3. 学生データ
   4. 統計データ


* 修飾
* デバッガ(GDB)
* 総合
** IPv4のブロードキャストアドレス
   IPv4のネットワークアドレスとサブネットマスクを引数として、ブロードキャストアドレス
   を算出するプログラムを作成せよ。実装に詰まる場合は以下の流れを参考にせよ。

   1. 1バイト(8ビット)データを2進数で出力する関数を作成せよ。

        void print_bit(unsigned char x)

   2. ipv4アドレスを2進数で出力する関数を作成せよ。

        void print_ipv4_addr(unsigned char *x)

        xは4バイトの配列とし、x[0]が第1オクテット,...x[3]が第4オクテットに対応するものとする。
        また、各オクテット毎にはドット(.)を出力し区切りを明確にせよ。

   3. unsigned char 型、要素4の配列で、IPv4アドレスと、サブネットマスクを表現することにし、
      これにビット演算を適用することでブロードキャストアドレスを算出せよ。

      トライ&エラー時の結果確認では、print_ipv4_addrが役に立つだろう。

   4. IPv4アドレス,サブネットマスクは4バイト(32ビット)の情報なので、ungiend int 型に収まるはずである。
      また、int型として扱うことで配列の各要素に対して行っていた演算を1度に実行できるはずである。
      この考えを元に、unsigned char 型,要素数4の配列をunsigned int型の配列として扱いブロードキャストアドレスを
      算出してみよ。

      ヒント : キャストを利用せよ。

   5. この問題の場合、unsigned char 型 要素数4 と unsigned int型のデータは同じデータなので、
      同一のものとして扱えるよいだろう。この目的のために共用体を利用してみよ。

   6. 練習としてプログラムに思いつく修正を加えてみよ。
      1. ネットワークアドレスを算出する関数を作成せよ。
      2. Ipv4アドレスの設定を4つの引数 func(oct1, oct2, oct3, oct4)の様な形式で設定する関数を
	 作成せよ。
      3. IPv4アドレスの設定を 192.168.10.3の様な形式で指定できるようにせよ。
      4. ブロードキャストアドレスを192.168.10.3/25の様な形式で指定できるようにせよ。

** 関数単体試験
*** モジュールの分離
1. 「条件分岐」問題2.2を解いてみよ。
    ファイル名はsuiryou.cとする。

2. suiryou_testディレクトリを作成しsuiryou.cをそこに移動せよ。
3. suiryou.cについて、警告用関数の別モジュールに分離せよ。また、ヘッダファイルを用意せよ。
4. これまで通り動作することを確認せよ。

*** Makefileの作成
1. 以下のMakefileを用意せよ。

$ cat Makefile
all: suiryou

suiryou : main.c suiryou.c suiryou.h
	gcc -Wall main.c suiryou.c -o suiryou

clean :
	rm -rf a.out *.o suiryou

2. 1のMakefileはsuiryou実行ファイルを作成するための依存関係が一つにまとまっている。
   そのため、main.c, suiryou.c, suiryou.hのどれが変更されてもmain.c, suiryou.cの
   コンパイルとリンクが行われる。
   依存関係の記述を修正してみよ。


*** CppUTest

** #includeって何してるの?
** ライブラリを作成する
** 簡易cat
** CDプレーヤーのモデル

** pingを変更してみる
 - [[https://www.gnu.org/software/inetutils/manual/html_node/index.html][GNU Inetutils]]

** netstatの仕組みを調べる
 - [[https://net-tools.sourceforge.io/][netstat]]

** netcat
 - [[https://ja.wikipedia.org/wiki/Netcat][netcat]]

** echoクライアント, echoサーバ
